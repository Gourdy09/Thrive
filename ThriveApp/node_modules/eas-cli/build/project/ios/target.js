"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApplePlatformFromDeviceFamily = exports.getApplePlatformFromSdkRoot = exports.getApplePlatformFromTarget = exports.findTargetByName = exports.findApplicationTarget = exports.resolveTargetsAsync = exports.resolveBareProjectTargetsAsync = exports.resolveManagedProjectTargetsAsync = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const joi_1 = tslib_1.__importDefault(require("joi"));
const bundleIdentifier_1 = require("./bundleIdentifier");
const entitlements_1 = require("./entitlements");
const constants_1 = require("../../credentials/ios/appstore/constants");
const workflow_1 = require("../workflow");
const AppExtensionsConfigSchema = joi_1.default.array().items(joi_1.default.object({
    targetName: joi_1.default.string().required(),
    bundleIdentifier: joi_1.default.string().required(),
    parentBundleIdentifier: joi_1.default.string(),
    entitlements: joi_1.default.object(),
}));
async function resolveManagedProjectTargetsAsync({ exp, projectDir, xcodeBuildContext, env, vcsClient, }) {
    const { buildScheme, buildConfiguration } = xcodeBuildContext;
    const applicationTargetName = buildScheme;
    const applicationTargetBundleIdentifier = await (0, bundleIdentifier_1.getBundleIdentifierAsync)(projectDir, exp, vcsClient, {
        targetName: applicationTargetName,
        buildConfiguration,
    });
    const applicationTargetEntitlements = await (0, entitlements_1.getManagedApplicationTargetEntitlementsAsync)(projectDir, env ?? {}, vcsClient);
    const appExtensions = exp.extra?.eas?.build?.experimental?.ios?.appExtensions ?? [];
    const { error } = AppExtensionsConfigSchema.validate(appExtensions, {
        allowUnknown: false,
        abortEarly: false,
    });
    if (error) {
        throw new Error(`Failed to validate "extra.eas.build.experimental.ios.appExtensions" in you app config.\n${error.message}`);
    }
    const extensionsTargets = appExtensions.map(extension => ({
        targetName: extension.targetName,
        buildConfiguration,
        bundleIdentifier: extension.bundleIdentifier,
        parentBundleIdentifier: extension.parentBundleIdentifier ?? applicationTargetBundleIdentifier,
        entitlements: extension.entitlements ?? {},
    }));
    return [
        {
            targetName: applicationTargetName,
            bundleIdentifier: applicationTargetBundleIdentifier,
            buildConfiguration,
            entitlements: applicationTargetEntitlements,
        },
        ...extensionsTargets,
    ];
}
exports.resolveManagedProjectTargetsAsync = resolveManagedProjectTargetsAsync;
async function resolveBareProjectTargetsAsync({ exp, projectDir, xcodeBuildContext, vcsClient, }) {
    const { buildScheme, buildConfiguration } = xcodeBuildContext;
    const result = [];
    const pbxProject = config_plugins_1.IOSConfig.XcodeUtils.getPbxproj(projectDir);
    const applicationTarget = await config_plugins_1.IOSConfig.Target.findApplicationTargetWithDependenciesAsync(projectDir, buildScheme);
    const bundleIdentifier = await (0, bundleIdentifier_1.getBundleIdentifierAsync)(projectDir, exp, vcsClient, {
        targetName: applicationTarget.name,
        buildConfiguration,
    });
    const entitlements = await (0, entitlements_1.getNativeTargetEntitlementsAsync)(projectDir, {
        targetName: applicationTarget.name,
        buildConfiguration,
    });
    result.push({
        targetName: applicationTarget.name,
        bundleIdentifier,
        buildConfiguration,
        entitlements: entitlements ?? {},
        buildSettings: resolveBareProjectBuildSettings(pbxProject, applicationTarget.name, buildConfiguration),
    });
    const dependencies = await resolveBareProjectDependenciesAsync({
        exp,
        projectDir,
        buildConfiguration,
        target: applicationTarget,
        bundleIdentifier,
        pbxProject,
        vcsClient,
    });
    if (dependencies.length > 0) {
        result.push(...dependencies);
    }
    return result;
}
exports.resolveBareProjectTargetsAsync = resolveBareProjectTargetsAsync;
async function resolveTargetsAsync(opts) {
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(opts.projectDir, eas_build_job_1.Platform.IOS, opts.vcsClient);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        return await resolveBareProjectTargetsAsync(opts);
    }
    else if (workflow === eas_build_job_1.Workflow.MANAGED) {
        return await resolveManagedProjectTargetsAsync(opts);
    }
    else {
        throw new Error(`Unknown workflow: ${workflow}`);
    }
}
exports.resolveTargetsAsync = resolveTargetsAsync;
async function resolveBareProjectDependenciesAsync({ exp, projectDir, buildConfiguration, target, bundleIdentifier, pbxProject, vcsClient, }) {
    const result = [];
    if (target.dependencies && target.dependencies.length > 0) {
        for (const dependency of target.dependencies) {
            if (!dependency.signable) {
                continue;
            }
            const dependencyBundleIdentifier = await (0, bundleIdentifier_1.getBundleIdentifierAsync)(projectDir, exp, vcsClient, {
                targetName: dependency.name,
                buildConfiguration,
            });
            const entitlements = await (0, entitlements_1.getNativeTargetEntitlementsAsync)(projectDir, {
                targetName: dependency.name,
                buildConfiguration,
            });
            result.push({
                targetName: dependency.name,
                buildConfiguration,
                bundleIdentifier: dependencyBundleIdentifier,
                parentBundleIdentifier: bundleIdentifier,
                entitlements: entitlements ?? {},
                buildSettings: resolveBareProjectBuildSettings(pbxProject, dependency.name, buildConfiguration),
            });
            const dependencyDependencies = await resolveBareProjectDependenciesAsync({
                exp,
                projectDir,
                buildConfiguration,
                target: dependency,
                bundleIdentifier: dependencyBundleIdentifier,
                pbxProject,
                vcsClient,
            });
            if (dependencyDependencies.length > 0) {
                result.push(...dependencyDependencies);
            }
        }
    }
    return result;
}
function findApplicationTarget(targets) {
    const applicationTarget = targets.find(({ parentBundleIdentifier }) => !parentBundleIdentifier);
    if (!applicationTarget) {
        throw new Error('Could not find the application target');
    }
    return applicationTarget;
}
exports.findApplicationTarget = findApplicationTarget;
function findTargetByName(targets, name) {
    const target = targets.find(target => target.targetName === name);
    if (!target) {
        throw new Error(`Could not find target '${name}'`);
    }
    return target;
}
exports.findTargetByName = findTargetByName;
function resolveBareProjectBuildSettings(project, targetName, buildConfiguration) {
    const xcBuildConfiguration = config_plugins_1.IOSConfig.Target.getXCBuildConfigurationFromPbxproj(project, {
        targetName,
        buildConfiguration,
    });
    return xcBuildConfiguration?.buildSettings ?? {};
}
/**
 * Get Apple Platform from the Xcode Target where possible.
 * @returns - Apple Platform when known, defaults to IOS when unknown
 */
function getApplePlatformFromTarget(target) {
    return (getApplePlatformFromSdkRoot(target) ??
        getApplePlatformFromDeviceFamily(target) ??
        constants_1.ApplePlatform.IOS);
}
exports.getApplePlatformFromTarget = getApplePlatformFromTarget;
/**
 * Get Apple Platform from the Xcode SDKROOT where possible.
 * @returns - Apple Platform when known, defaults to null when unknown
 */
function getApplePlatformFromSdkRoot(target) {
    const sdkRoot = target.buildSettings?.SDKROOT;
    if (!sdkRoot) {
        return null;
    }
    if (sdkRoot.includes('iphoneos')) {
        return constants_1.ApplePlatform.IOS;
    }
    else if (sdkRoot.includes('tvos')) {
        return constants_1.ApplePlatform.TV_OS;
    }
    else if (sdkRoot.includes('macosx')) {
        return constants_1.ApplePlatform.MAC_OS;
    }
    else {
        return null;
    }
}
exports.getApplePlatformFromSdkRoot = getApplePlatformFromSdkRoot;
/**
 * Get Apple Platform from the Xcode TARGETED_DEVICE_FAMILY where possible.
 *
 * References:
 * https://developer-mdn.apple.com/library/archive/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html
 * https://stackoverflow.com/questions/39677524/xcode-8-how-to-change-targeted-device-family#comment100316573_39677659
 *
 * @returns - Apple Platform when known, defaults to null when unknown
 */
function getApplePlatformFromDeviceFamily(target) {
    const deviceFamily = target.buildSettings?.TARGETED_DEVICE_FAMILY;
    if (!deviceFamily) {
        return null;
    }
    if (typeof deviceFamily === 'string') {
        const devices = deviceFamily.split(',');
        const arbitraryDevice = devices[0];
        const deviceFamilyNumber = Number(arbitraryDevice);
        return deviceFamilyToPlatform(deviceFamilyNumber);
    }
    else if (typeof deviceFamily === 'number') {
        return deviceFamilyToPlatform(deviceFamily);
    }
    throw new Error(`Unexpected device family type in XCode build settings: ${JSON.stringify(deviceFamily)}`);
}
exports.getApplePlatformFromDeviceFamily = getApplePlatformFromDeviceFamily;
function deviceFamilyToPlatform(deviceFamily) {
    if (deviceFamily === 1 || deviceFamily === 2) {
        return constants_1.ApplePlatform.IOS;
    }
    else if (deviceFamily === 3) {
        return constants_1.ApplePlatform.TV_OS;
    }
    else {
        return null;
    }
}
