"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGradleCommand = exports.resolveConfigValue = exports.getAppBuildGradleAsync = exports.DEFAULT_MODULE_NAME = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const parser_1 = tslib_1.__importDefault(require("gradle-to-js/lib/parser"));
exports.DEFAULT_MODULE_NAME = 'app';
async function getAppBuildGradleAsync(projectDir) {
    const buildGradlePath = config_plugins_1.AndroidConfig.Paths.getAppBuildGradleFilePath(projectDir);
    const rawBuildGradle = await fs_extra_1.default.readFile(buildGradlePath, 'utf8');
    // filter out any comments
    // when comments are present, gradle-to-js fails to parse the file
    const rawBuildGradleWithoutComments = rawBuildGradle
        .split('\n')
        .filter(line => !line.trim().startsWith('//'))
        .join('\n');
    return await parser_1.default.parseText(rawBuildGradleWithoutComments);
}
exports.getAppBuildGradleAsync = getAppBuildGradleAsync;
function resolveConfigValue(buildGradle, field, flavor) {
    return ((flavor && buildGradle?.android?.productFlavors?.[flavor]?.[field]) ??
        buildGradle?.android?.defaultConfig?.[field]);
}
exports.resolveConfigValue = resolveConfigValue;
/**
 * Extract module name, buildType, and flavor from the gradle command.
 *
 * @param cmd can be any valid string that can be added after `./gradlew` call
 * e.g.
 *   - :app:buildDebug
 *   - app:buildDebug
 *   - buildDebug
 *   - buildDebug --console verbose
 * @param buildGradle is used to verify correct casing of the first letter in
 * the flavor name
 **/
function parseGradleCommand(cmd, buildGradle) {
    const hasFlavorDimensions = (buildGradle.android?.flavorDimensions ?? '').split(',').length > 1;
    if (hasFlavorDimensions) {
        throw new Error('flavorDimensions in build.gradle are not supported yet');
    }
    const flavors = new Set(Object.keys(buildGradle?.android?.productFlavors ?? {}));
    // remove any params specified after command name
    const [withoutParams] = cmd.split(' ');
    // remove leading :
    const rawCmd = withoutParams.startsWith(':') ? withoutParams.slice(1) : withoutParams;
    // separate moduleName and rest of the definition
    const splitCmd = rawCmd.split(':');
    const [moduleName, taskName] = splitCmd.length > 1 ? [splitCmd[0], splitCmd[1]] : [undefined, splitCmd[0]];
    const matchResult = taskName.match(/(build|bundle|assemble|package)(.*)(Release|Debug)/);
    if (!matchResult) {
        throw new Error(`Failed to parse gradle command: ${cmd}`);
    }
    let flavor;
    if (matchResult[2]) {
        const [firstLetter, rest] = [matchResult[2].slice(0, 1), matchResult[2].slice(1)];
        // first letter casing is not known based on gradle task name
        // so we need to check both options
        const flavorOptions = [
            firstLetter.toLowerCase().concat(rest),
            firstLetter.toUpperCase().concat(rest),
        ];
        flavorOptions.forEach(option => {
            if (flavors.has(option)) {
                flavor = option;
            }
        });
        if (!flavor) {
            throw new Error(`flavor ${firstLetter.toLowerCase().concat(rest)} is not defined`);
        }
    }
    return {
        moduleName,
        flavor,
        buildType: matchResult[3] ? matchResult[3].toLowerCase() : undefined,
    };
}
exports.parseGradleCommand = parseGradleCommand;
