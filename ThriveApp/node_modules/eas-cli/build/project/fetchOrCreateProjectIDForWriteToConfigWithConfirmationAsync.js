"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findProjectIdByAccountNameAndSlugNullableAsync = exports.fetchOrCreateProjectIDForWriteToConfigWithConfirmationAsync = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const url_1 = require("../build/utils/url");
const generated_1 = require("../graphql/generated");
const AppMutation_1 = require("../graphql/mutations/AppMutation");
const AppQuery_1 = require("../graphql/queries/AppQuery");
const log_1 = require("../log");
const ora_1 = require("../ora");
const prompts_1 = require("../prompts");
/**
 * 1. Looks for an existing project on EAS servers. If found, ask the user whether this is the
 *    project they would like to link. If yes, return that. If not, throw.
 * 2. If no existing project is found, ask the user whether they would like to register a new one.
 *    If yes, register and return that. If not, throw.
 */
async function fetchOrCreateProjectIDForWriteToConfigWithConfirmationAsync(graphqlClient, projectInfo, options, actor) {
    const { accountName, projectName } = projectInfo;
    const projectFullName = `@${accountName}/${projectName}`;
    if (options.nonInteractive) {
        throw new Error(`Must configure EAS project by running 'eas init' before this command can be run in non-interactive mode.`);
    }
    const allAccounts = actor.accounts;
    const accountNamesWhereUserHasSufficientPublishPermissions = new Set(allAccounts
        .filter(a => a.users.find(it => it.actor.id === actor.id)?.role !== generated_1.Role.ViewOnly)
        .map(it => it.name));
    const account = allAccounts.find(a => a.name === accountName);
    if (!account) {
        throw new Error(`You must have access to the ${accountName} account to configure this EAS project.`);
    }
    const projectIdOnServer = await findProjectIdByAccountNameAndSlugNullableAsync(graphqlClient, accountName, projectName);
    if (projectIdOnServer) {
        const affirmedLink = await (0, prompts_1.confirmAsync)({
            message: `Existing EAS project found for ${projectFullName} (id = ${projectIdOnServer}). Configure this project?`,
        });
        if (!affirmedLink) {
            throw new Error(`EAS project ID configuration canceled for ${projectFullName}. Run 'eas init' to configure.`);
        }
        return projectIdOnServer;
    }
    if (!accountNamesWhereUserHasSufficientPublishPermissions.has(accountName)) {
        throw new Error(`You don't have permission to create a new project on the ${accountName} account and no matching project already exists on the account.`);
    }
    const affirmedCreate = await (0, prompts_1.confirmAsync)({
        message: `Would you like to automatically create an EAS project for ${projectFullName}?`,
    });
    if (!affirmedCreate) {
        throw new Error(`EAS project ID configuration canceled for ${projectFullName}. Run 'eas init' to configure.`);
    }
    const projectDashboardUrl = (0, url_1.getProjectDashboardUrl)(accountName, projectName);
    const projectLink = (0, log_1.link)(projectDashboardUrl, { text: projectFullName });
    const spinner = (0, ora_1.ora)(`Creating ${chalk_1.default.bold(projectFullName)} on Expo`).start();
    try {
        const id = await AppMutation_1.AppMutation.createAppAsync(graphqlClient, {
            accountId: account.id,
            projectName,
            privacy: projectInfo.privacy ?? generated_1.AppPrivacy.Public,
        });
        spinner.succeed(`Created ${chalk_1.default.bold(projectLink)} on Expo`);
        return id;
    }
    catch (err) {
        spinner.fail();
        throw err;
    }
}
exports.fetchOrCreateProjectIDForWriteToConfigWithConfirmationAsync = fetchOrCreateProjectIDForWriteToConfigWithConfirmationAsync;
/**
 * Finds project by `@accountName/slug` and returns its ID, return null if the project does not exist.
 * @param accountName account name
 * @param slug project slug
 * @returns A promise resolving to Project ID, null if it doesn't exist
 */
async function findProjectIdByAccountNameAndSlugNullableAsync(graphqlClient, accountName, slug) {
    try {
        const { id } = await AppQuery_1.AppQuery.byFullNameAsync(graphqlClient, `@${accountName}/${slug}`);
        return id;
    }
    catch (err) {
        if (err.graphQLErrors?.some((it) => it.extensions?.errorCode !== 'EXPERIENCE_NOT_FOUND')) {
            throw err;
        }
        return null;
    }
}
exports.findProjectIdByAccountNameAndSlugNullableAsync = findProjectIdByAccountNameAndSlugNullableAsync;
