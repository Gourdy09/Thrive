"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMetroConfigForManagedWorkflowAsync = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const resolve_from_1 = tslib_1.__importDefault(require("resolve-from"));
const log_1 = tslib_1.__importStar(require("../log"));
const prompts_1 = require("../prompts");
async function validateMetroConfigForManagedWorkflowAsync(ctx) {
    if (!(await configExistsAsync(ctx.projectDir))) {
        return;
    }
    const metroConfig = await loadConfigAsync(ctx.projectDir);
    const hasHashAssetFilesPlugin = metroConfig.transformer?.assetPlugins?.find((plugin) => plugin.match(/expo-asset[/|\\]tools[/|\\]hashAssetFiles/));
    if (!hasHashAssetFilesPlugin) {
        log_1.default.warn(`It looks like that you are using a custom ${chalk_1.default.bold('metro.config.js')} that does not extend ${chalk_1.default.bold('@expo/metro-config')}.`);
        log_1.default.warn('This can result in unexpected and hard to debug issues, like missing assets in the production bundle.');
        if (!ctx.nonInteractive) {
            log_1.default.warn(`We recommend you to abort, fix the ${chalk_1.default.bold('metro.config.js')}, and try again.`);
        }
        log_1.default.warn((0, log_1.learnMore)('https://docs.expo.dev/guides/customizing-metro/', {
            learnMoreMessage: 'Learn more on customizing Metro',
        }));
        if (ctx.nonInteractive) {
            log_1.default.warn("You've run EAS CLI in non-interactive mode, proceeding...");
            return;
        }
        const shouldAbort = await (0, prompts_1.confirmAsync)({
            message: 'Would you like to abort?',
        });
        if (shouldAbort) {
            log_1.default.error('Aborting...');
            core_1.Errors.exit(1);
        }
    }
}
exports.validateMetroConfigForManagedWorkflowAsync = validateMetroConfigForManagedWorkflowAsync;
function importMetroConfigFromProject(projectDir) {
    const resolvedPath = resolve_from_1.default.silent(projectDir, 'metro-config');
    if (!resolvedPath) {
        throw new MetroConfigPackageMissingError('Missing package "metro-config" in the project. ' +
            'This usually means `react-native` is not installed. ' +
            'Verify that dependencies in package.json include "react-native" ' +
            'and run `yarn` or `npm install`.');
    }
    return require(resolvedPath);
}
async function configExistsAsync(projectRoot) {
    try {
        const MetroConfig = importMetroConfigFromProject(projectRoot);
        const result = await MetroConfig.resolveConfig(undefined, projectRoot);
        return !result.isEmpty;
    }
    catch (err) {
        if (err instanceof MetroConfigPackageMissingError) {
            return false;
        }
        else {
            throw err;
        }
    }
}
async function loadConfigAsync(projectDir) {
    const MetroConfig = importMetroConfigFromProject(projectDir);
    return await MetroConfig.loadConfig({ cwd: projectDir }, {});
}
class MetroConfigPackageMissingError extends Error {
}
