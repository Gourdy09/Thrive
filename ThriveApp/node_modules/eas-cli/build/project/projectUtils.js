"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDisplayNameForProjectIdAsync = exports.getOwnerAccountForProjectIdAsync = exports.installExpoUpdatesAsync = exports.isModernExpoUpdatesCLIWithRuntimeVersionCommandSupportedAsync = exports.enforceRollBackToEmbeddedUpdateSupportAsync = exports.validateAppVersionRuntimePolicySupportAsync = exports.isUsingEASUpdate = exports.isExpoUpdatesInstalledOrAvailable = exports.isExpoUpdatesInstalledAsDevDependency = exports.isExpoNotificationsInstalled = exports.isExpoUpdatesInstalled = exports.getProjectConfigDescription = exports.toAppPrivacy = exports.getUsername = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const resolve_from_1 = tslib_1.__importDefault(require("resolve-from"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const api_1 = require("../api");
const generated_1 = require("../graphql/generated");
const AppQuery_1 = require("../graphql/queries/AppQuery");
const log_1 = tslib_1.__importStar(require("../log"));
const expoCli_1 = require("../utils/expoCli");
function getUsername(exp, user) {
    switch (user.__typename) {
        case 'User':
            return user.username;
        case 'SSOUser':
            return user.username;
        case 'Robot':
            // owner field is necessary to run `expo prebuild`
            if (!exp.owner) {
                throw new Error('The "owner" manifest property is required when using robot users. See: https://docs.expo.dev/versions/latest/config/app/#owner');
            }
            // robot users don't have usernames
            return undefined;
    }
}
exports.getUsername = getUsername;
const toAppPrivacy = (privacy) => {
    if (privacy === 'public') {
        return generated_1.AppPrivacy.Public;
    }
    else if (privacy === 'hidden') {
        return generated_1.AppPrivacy.Hidden;
    }
    else {
        return generated_1.AppPrivacy.Unlisted;
    }
};
exports.toAppPrivacy = toAppPrivacy;
/**
 * Return a useful name describing the project config.
 * - dynamic: app.config.js
 * - static: app.json
 * - custom path app config relative to root folder
 * - both: app.config.js or app.json
 */
function getProjectConfigDescription(projectDir) {
    const paths = (0, config_1.getConfigFilePaths)(projectDir);
    if (paths.dynamicConfigPath) {
        const relativeDynamicConfigPath = path_1.default.relative(projectDir, paths.dynamicConfigPath);
        if (paths.staticConfigPath) {
            return `${relativeDynamicConfigPath} or ${path_1.default.relative(projectDir, paths.staticConfigPath)}`;
        }
        return relativeDynamicConfigPath;
    }
    else if (paths.staticConfigPath) {
        return path_1.default.relative(projectDir, paths.staticConfigPath);
    }
    return 'app.config.js/app.json';
}
exports.getProjectConfigDescription = getProjectConfigDescription;
function isExpoUpdatesInstalled(projectDir) {
    const packageJson = (0, config_1.getPackageJson)(projectDir);
    return !!(packageJson.dependencies && 'expo-updates' in packageJson.dependencies);
}
exports.isExpoUpdatesInstalled = isExpoUpdatesInstalled;
function isExpoNotificationsInstalled(projectDir) {
    const packageJson = (0, config_1.getPackageJson)(projectDir);
    return !!(packageJson.dependencies && 'expo-notifications' in packageJson.dependencies);
}
exports.isExpoNotificationsInstalled = isExpoNotificationsInstalled;
function isExpoUpdatesInstalledAsDevDependency(projectDir) {
    const packageJson = (0, config_1.getPackageJson)(projectDir);
    return !!(packageJson.devDependencies && 'expo-updates' in packageJson.devDependencies);
}
exports.isExpoUpdatesInstalledAsDevDependency = isExpoUpdatesInstalledAsDevDependency;
function isExpoUpdatesInstalledOrAvailable(projectDir, sdkVersion) {
    // before sdk 44, expo-updates was included in with the expo module
    if (sdkVersion && semver_1.default.lt(sdkVersion, '44.0.0')) {
        return true;
    }
    return isExpoUpdatesInstalled(projectDir);
}
exports.isExpoUpdatesInstalledOrAvailable = isExpoUpdatesInstalledOrAvailable;
function isUsingEASUpdate(exp, projectId) {
    return exp.updates?.url === (0, api_1.getEASUpdateURL)(projectId);
}
exports.isUsingEASUpdate = isUsingEASUpdate;
async function getExpoUpdatesPackageVersionIfInstalledAsync(projectDir) {
    const maybePackageJson = resolve_from_1.default.silent(projectDir, 'expo-updates/package.json');
    if (!maybePackageJson) {
        return null;
    }
    const { version } = await fs_extra_1.default.readJson(maybePackageJson);
    return version ?? null;
}
async function validateAppVersionRuntimePolicySupportAsync(projectDir, exp) {
    if (typeof exp.runtimeVersion !== 'object' || exp.runtimeVersion?.policy !== 'appVersion') {
        return;
    }
    const expoUpdatesPackageVersion = await getExpoUpdatesPackageVersionIfInstalledAsync(projectDir);
    if (expoUpdatesPackageVersion !== null &&
        (semver_1.default.gte(expoUpdatesPackageVersion, '0.14.4') ||
            expoUpdatesPackageVersion.includes('canary'))) {
        return;
    }
    log_1.default.warn(`You need to be on SDK 46 or higher, and use expo-updates >= 0.14.4 to use appVersion runtime policy.`);
}
exports.validateAppVersionRuntimePolicySupportAsync = validateAppVersionRuntimePolicySupportAsync;
async function enforceRollBackToEmbeddedUpdateSupportAsync(projectDir) {
    const expoUpdatesPackageVersion = await getExpoUpdatesPackageVersionIfInstalledAsync(projectDir);
    if (expoUpdatesPackageVersion !== null &&
        (semver_1.default.gte(expoUpdatesPackageVersion, '0.19.0') ||
            expoUpdatesPackageVersion.includes('canary'))) {
        return;
    }
    throw new Error(`The expo-updates package must have a version >= 0.19.0 to use roll back to embedded, which corresponds to Expo SDK 50 or greater. ${(0, log_1.learnMore)('https://docs.expo.dev/workflow/upgrading-expo-sdk-walkthrough/')}`);
}
exports.enforceRollBackToEmbeddedUpdateSupportAsync = enforceRollBackToEmbeddedUpdateSupportAsync;
async function isModernExpoUpdatesCLIWithRuntimeVersionCommandSupportedAsync(projectDir) {
    const expoUpdatesPackageVersion = await getExpoUpdatesPackageVersionIfInstalledAsync(projectDir);
    if (expoUpdatesPackageVersion === null) {
        return false;
    }
    if (expoUpdatesPackageVersion.includes('canary')) {
        return true;
    }
    // Anything SDK 51 or greater uses the expo-updates CLI
    return semver_1.default.gte(expoUpdatesPackageVersion, '0.25.4');
}
exports.isModernExpoUpdatesCLIWithRuntimeVersionCommandSupportedAsync = isModernExpoUpdatesCLIWithRuntimeVersionCommandSupportedAsync;
async function installExpoUpdatesAsync(projectDir, options) {
    log_1.default.log(chalk_1.default.gray `> npx expo install expo-updates`);
    try {
        await (0, expoCli_1.expoCommandAsync)(projectDir, ['install', 'expo-updates'], { silent: options?.silent });
    }
    catch (error) {
        if (options?.silent) {
            log_1.default.error('stdout' in error ? error.stdout : error.message);
        }
        throw error;
    }
}
exports.installExpoUpdatesAsync = installExpoUpdatesAsync;
async function getOwnerAccountForProjectIdAsync(graphqlClient, projectId) {
    const app = await AppQuery_1.AppQuery.byIdAsync(graphqlClient, projectId);
    return app.ownerAccount;
}
exports.getOwnerAccountForProjectIdAsync = getOwnerAccountForProjectIdAsync;
async function getDisplayNameForProjectIdAsync(graphqlClient, projectId) {
    const app = await AppQuery_1.AppQuery.byIdAsync(graphqlClient, projectId);
    return app.fullName;
}
exports.getDisplayNameForProjectIdAsync = getDisplayNameForProjectIdAsync;
