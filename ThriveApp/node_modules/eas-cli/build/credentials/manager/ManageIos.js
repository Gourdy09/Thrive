"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManageIos = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const assert_1 = tslib_1.__importDefault(require("assert"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const Actions_1 = require("./Actions");
const HelperActions_1 = require("./HelperActions");
const IosActions_1 = require("./IosActions");
const SelectBuildProfileFromEasJson_1 = require("./SelectBuildProfileFromEasJson");
const SelectIosDistributionTypeGraphqlFromBuildProfile_1 = require("./SelectIosDistributionTypeGraphqlFromBuildProfile");
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importStar(require("../../log"));
const scheme_1 = require("../../project/ios/scheme");
const target_1 = require("../../project/ios/target");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const actions_1 = require("../../user/actions");
const context_1 = require("../context");
const AscApiKeyUtils_1 = require("../ios/actions/AscApiKeyUtils");
const AssignAscApiKey_1 = require("../ios/actions/AssignAscApiKey");
const AssignPushKey_1 = require("../ios/actions/AssignPushKey");
const BuildCredentialsUtils_1 = require("../ios/actions/BuildCredentialsUtils");
const CreateAscApiKey_1 = require("../ios/actions/CreateAscApiKey");
const CreateDistributionCertificate_1 = require("../ios/actions/CreateDistributionCertificate");
const CreatePushKey_1 = require("../ios/actions/CreatePushKey");
const DistributionCertificateUtils_1 = require("../ios/actions/DistributionCertificateUtils");
const PushKeyUtils_1 = require("../ios/actions/PushKeyUtils");
const RemoveAscApiKey_1 = require("../ios/actions/RemoveAscApiKey");
const RemoveDistributionCertificate_1 = require("../ios/actions/RemoveDistributionCertificate");
const RemoveProvisioningProfile_1 = require("../ios/actions/RemoveProvisioningProfile");
const RemovePushKey_1 = require("../ios/actions/RemovePushKey");
const SetUpAdhocProvisioningProfile_1 = require("../ios/actions/SetUpAdhocProvisioningProfile");
const SetUpAscApiKey_1 = require("../ios/actions/SetUpAscApiKey");
const SetUpBuildCredentials_1 = require("../ios/actions/SetUpBuildCredentials");
const SetUpBuildCredentialsFromCredentialsJson_1 = require("../ios/actions/SetUpBuildCredentialsFromCredentialsJson");
const SetUpProvisioningProfile_1 = require("../ios/actions/SetUpProvisioningProfile");
const SetUpPushKey_1 = require("../ios/actions/SetUpPushKey");
const UpdateCredentialsJson_1 = require("../ios/actions/UpdateCredentialsJson");
const printCredentials_1 = require("../ios/utils/printCredentials");
class ManageIos {
    constructor(callingAction, projectDir) {
        this.callingAction = callingAction;
        this.projectDir = projectDir;
    }
    async runAsync(currentActions = IosActions_1.highLevelActions) {
        const buildProfile = this.callingAction.projectInfo
            ? await new SelectBuildProfileFromEasJson_1.SelectBuildProfileFromEasJson(this.projectDir, eas_build_job_1.Platform.IOS).runAsync()
            : null;
        let projectInfo = null;
        if (this.callingAction.projectInfo) {
            const { exp, projectId } = await this.callingAction.getDynamicPrivateProjectConfigAsync({
                env: buildProfile?.env,
            });
            projectInfo = { exp, projectId };
        }
        const ctx = new context_1.CredentialsContext({
            projectDir: process.cwd(),
            projectInfo,
            user: this.callingAction.actor,
            graphqlClient: this.callingAction.graphqlClient,
            analytics: this.callingAction.analytics,
            env: buildProfile?.env,
            nonInteractive: false,
            vcsClient: this.callingAction.vcsClient,
        });
        const buildCredentialsActions = (0, IosActions_1.getBuildCredentialsActions)(ctx);
        const pushKeyActions = (0, IosActions_1.getPushKeyActions)(ctx);
        const ascApiKeyActions = (0, IosActions_1.getAscApiKeyActions)(ctx);
        await ctx.bestEffortAppStoreAuthenticateAsync();
        const getAccountForProjectAsync = async (projectId) => {
            return await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(ctx.graphqlClient, projectId);
        };
        const account = ctx.hasProjectContext
            ? await getAccountForProjectAsync(ctx.projectId)
            : (0, actions_1.ensureActorHasPrimaryAccount)(ctx.user);
        let app = null;
        let targets = null;
        if (ctx.hasProjectContext) {
            (0, assert_1.default)(buildProfile, 'buildProfile must be defined in project context');
            const projectContext = await this.createProjectContextAsync(ctx, account, buildProfile);
            app = projectContext.app;
            targets = projectContext.targets;
        }
        while (true) {
            try {
                if (ctx.hasProjectContext) {
                    (0, assert_1.default)(targets && app);
                    const iosAppCredentialsMap = {};
                    for (const target of targets) {
                        const appLookupParams = await (0, BuildCredentialsUtils_1.getAppLookupParamsFromContextAsync)(ctx, target);
                        iosAppCredentialsMap[target.targetName] =
                            await ctx.ios.getIosAppCredentialsWithCommonFieldsAsync(ctx.graphqlClient, appLookupParams);
                    }
                    (0, printCredentials_1.displayIosCredentials)(app, iosAppCredentialsMap, targets);
                }
                const { action: chosenAction } = await (0, prompts_1.promptAsync)({
                    type: 'select',
                    name: 'action',
                    message: 'What do you want to do?',
                    choices: currentActions.map(action => ({
                        value: action.value,
                        title: action.title,
                    })),
                });
                const actionInfo = currentActions.find(action => action.value === chosenAction);
                if (!actionInfo) {
                    throw new Error('Action not supported yet');
                }
                if (actionInfo.scope === Actions_1.Scope.Manager) {
                    if (chosenAction === Actions_1.IosActionType.ManageBuildCredentials) {
                        currentActions = buildCredentialsActions;
                        continue;
                    }
                    else if (chosenAction === Actions_1.IosActionType.ManageCredentialsJson) {
                        currentActions = IosActions_1.credentialsJsonActions;
                        continue;
                    }
                    else if (chosenAction === Actions_1.IosActionType.ManagePushKey) {
                        currentActions = pushKeyActions;
                        continue;
                    }
                    else if (chosenAction === Actions_1.IosActionType.ManageAscApiKey) {
                        currentActions = ascApiKeyActions;
                        continue;
                    }
                    else if (chosenAction === Actions_1.IosActionType.GoBackToHighLevelActions) {
                        currentActions = IosActions_1.highLevelActions;
                        continue;
                    }
                    else if (chosenAction === Actions_1.IosActionType.GoBackToCaller) {
                        await this.callingAction.runAsync(ctx);
                        return;
                    }
                    else if (chosenAction === Actions_1.IosActionType.Exit) {
                        return;
                    }
                }
                else if (actionInfo.scope === Actions_1.Scope.Project) {
                    (0, assert_1.default)(ctx.hasProjectContext, 'You must be in your project directory in order to perform this action');
                    await this.runProjectSpecificActionAsync(ctx, (0, nullthrows_1.default)(app, 'app must be defined in project context'), (0, nullthrows_1.default)(targets, 'targets must be defined in project context'), (0, nullthrows_1.default)(buildProfile, 'buildProfile must be defined in project context'), chosenAction);
                }
                else if (actionInfo.scope === Actions_1.Scope.Account) {
                    await this.runAccountSpecificActionAsync(ctx, account, chosenAction);
                }
                else {
                    throw new Error('Unknown action selected');
                }
            }
            catch (err) {
                log_1.default.error(err);
                if (process.env.DEBUG) {
                    throw err; // breaks out of the loop so we can get stack trace
                }
                log_1.default.error(`Cryptic error? ${(0, log_1.learnMore)('https://expo.fyi/cryptic-error-eas')}`);
            }
            await new HelperActions_1.PressAnyKeyToContinue().runAsync();
        }
    }
    async createProjectContextAsync(ctx, account, buildProfile) {
        (0, assert_1.default)(ctx.hasProjectContext, 'createProjectContextAsync: must have project context.');
        const app = { account, projectName: ctx.exp.slug };
        const xcodeBuildContext = await (0, scheme_1.resolveXcodeBuildContextAsync)({
            projectDir: ctx.projectDir,
            nonInteractive: ctx.nonInteractive,
            exp: ctx.exp,
            vcsClient: ctx.vcsClient,
        }, buildProfile);
        const targets = await (0, target_1.resolveTargetsAsync)({
            exp: ctx.exp,
            projectDir: ctx.projectDir,
            xcodeBuildContext,
            env: buildProfile.env,
            vcsClient: ctx.vcsClient,
        });
        return {
            app,
            targets,
        };
    }
    async runAccountSpecificActionAsync(ctx, account, action) {
        if (action === Actions_1.IosActionType.RemoveDistributionCertificate) {
            await new RemoveDistributionCertificate_1.SelectAndRemoveDistributionCertificate(account).runAsync(ctx);
        }
        else if (action === Actions_1.IosActionType.CreateDistributionCertificate) {
            await new CreateDistributionCertificate_1.CreateDistributionCertificate(account).runAsync(ctx);
        }
        else if (action === Actions_1.IosActionType.CreatePushKey) {
            await new CreatePushKey_1.CreatePushKey(account).runAsync(ctx);
        }
        else if (action === Actions_1.IosActionType.CreateAscApiKeyForSubmissions) {
            await new CreateAscApiKey_1.CreateAscApiKey(account).runAsync(ctx, AscApiKeyUtils_1.AppStoreApiKeyPurpose.SUBMISSION_SERVICE);
        }
        else if (action === Actions_1.IosActionType.RemovePushKey) {
            await new RemovePushKey_1.SelectAndRemovePushKey(account).runAsync(ctx);
        }
        else if (action === Actions_1.IosActionType.RemoveAscApiKey) {
            await new RemoveAscApiKey_1.SelectAndRemoveAscApiKey(account).runAsync(ctx);
        }
    }
    async runProjectSpecificActionAsync(ctx, app, targets, buildProfile, action) {
        if (action === Actions_1.IosActionType.SetUpBuildCredentials) {
            await new SetUpBuildCredentials_1.SetUpBuildCredentials({
                app,
                targets,
                distribution: buildProfile.distribution,
                enterpriseProvisioning: buildProfile.enterpriseProvisioning,
            }).runAsync(ctx);
            return;
        }
        const distributionType = await new SelectIosDistributionTypeGraphqlFromBuildProfile_1.SelectIosDistributionTypeGraphqlFromBuildProfile(buildProfile).runAsync(ctx);
        if (action === Actions_1.IosActionType.SetUpBuildCredentialsFromCredentialsJson) {
            await new SetUpBuildCredentialsFromCredentialsJson_1.SetUpBuildCredentialsFromCredentialsJson(app, targets, distributionType).runAsync(ctx);
            return;
        }
        else if (action === Actions_1.IosActionType.UpdateCredentialsJson) {
            await new UpdateCredentialsJson_1.UpdateCredentialsJson(app, targets, distributionType).runAsync(ctx);
            return;
        }
        const target = await this.selectTargetAsync(targets);
        const appLookupParams = await (0, BuildCredentialsUtils_1.getAppLookupParamsFromContextAsync)(ctx, target);
        switch (action) {
            case Actions_1.IosActionType.UseExistingDistributionCertificate: {
                const distCert = await (0, DistributionCertificateUtils_1.selectValidDistributionCertificateAsync)(ctx, appLookupParams);
                if (!distCert) {
                    return;
                }
                await this.setupProvisioningProfileWithSpecificDistCertAsync(ctx, target, appLookupParams, distCert, distributionType);
                return;
            }
            case Actions_1.IosActionType.CreateDistributionCertificate: {
                const distCert = await new CreateDistributionCertificate_1.CreateDistributionCertificate(appLookupParams.account).runAsync(ctx);
                const confirm = await (0, prompts_1.confirmAsync)({
                    message: `Do you want ${appLookupParams.projectName} to use the new Distribution Certificate?`,
                });
                if (confirm) {
                    await this.setupProvisioningProfileWithSpecificDistCertAsync(ctx, target, appLookupParams, distCert, distributionType);
                }
                return;
            }
            case Actions_1.IosActionType.RemoveProvisioningProfile: {
                const iosAppCredentials = await ctx.ios.getIosAppCredentialsWithCommonFieldsAsync(ctx.graphqlClient, appLookupParams);
                const provisioningProfile = iosAppCredentials?.iosAppBuildCredentialsList.find(buildCredentials => buildCredentials.iosDistributionType === distributionType)?.provisioningProfile;
                if (!provisioningProfile) {
                    log_1.default.log(`No provisioning profile associated with the ${distributionType} configuration of ${appLookupParams.projectName}`);
                    return;
                }
                const confirm = await (0, prompts_1.confirmAsync)({
                    message: `Delete the provisioning profile associated with the ${distributionType} configuration of ${appLookupParams.projectName}?`,
                });
                if (confirm) {
                    await new RemoveProvisioningProfile_1.RemoveProvisioningProfiles([appLookupParams], [provisioningProfile]).runAsync(ctx);
                }
                return;
            }
            case Actions_1.IosActionType.SetUpPushKey: {
                const setupPushKeyAction = new SetUpPushKey_1.SetUpPushKey(appLookupParams);
                const isPushKeySetup = await setupPushKeyAction.isPushKeySetupAsync(ctx);
                if (isPushKeySetup) {
                    log_1.default.log(`Push Key is already set up for ${appLookupParams.projectName} ${appLookupParams.bundleIdentifier}`);
                }
                else {
                    await new SetUpPushKey_1.SetUpPushKey(appLookupParams).runAsync(ctx);
                }
                return;
            }
            case Actions_1.IosActionType.CreatePushKey: {
                const pushKey = await new CreatePushKey_1.CreatePushKey(appLookupParams.account).runAsync(ctx);
                const confirm = await (0, prompts_1.confirmAsync)({
                    message: `Do you want ${appLookupParams.projectName} to use the new Push Key?`,
                });
                if (confirm) {
                    await new AssignPushKey_1.AssignPushKey(appLookupParams).runAsync(ctx, pushKey);
                }
                return;
            }
            case Actions_1.IosActionType.UseExistingPushKey: {
                const selectedPushKey = await (0, PushKeyUtils_1.selectPushKeyAsync)(ctx, appLookupParams.account);
                if (selectedPushKey) {
                    await new AssignPushKey_1.AssignPushKey(appLookupParams).runAsync(ctx, selectedPushKey);
                }
                return;
            }
            case Actions_1.IosActionType.SetUpAscApiKeyForSubmissions: {
                await new SetUpAscApiKey_1.SetUpAscApiKey(appLookupParams, AscApiKeyUtils_1.AppStoreApiKeyPurpose.SUBMISSION_SERVICE).runAsync(ctx);
                return;
            }
            case Actions_1.IosActionType.UseExistingAscApiKeyForSubmissions: {
                const ascApiKey = await (0, AscApiKeyUtils_1.selectAscApiKeysFromAccountAsync)(ctx, appLookupParams.account, {
                    filterDifferentAppleTeam: true,
                });
                if (ascApiKey) {
                    await new AssignAscApiKey_1.AssignAscApiKey(appLookupParams).runAsync(ctx, ascApiKey, AscApiKeyUtils_1.AppStoreApiKeyPurpose.SUBMISSION_SERVICE);
                }
                return;
            }
            case Actions_1.IosActionType.CreateAscApiKeyForSubmissions: {
                const ascApiKey = await new CreateAscApiKey_1.CreateAscApiKey(appLookupParams.account).runAsync(ctx, AscApiKeyUtils_1.AppStoreApiKeyPurpose.SUBMISSION_SERVICE);
                const confirm = await (0, prompts_1.confirmAsync)({
                    message: `Do you want ${appLookupParams.projectName} to use the new API Key?`,
                });
                if (confirm) {
                    await new AssignAscApiKey_1.AssignAscApiKey(appLookupParams).runAsync(ctx, ascApiKey, AscApiKeyUtils_1.AppStoreApiKeyPurpose.SUBMISSION_SERVICE);
                }
                return;
            }
            default:
                throw new Error('Unknown action selected');
        }
    }
    async setupProvisioningProfileWithSpecificDistCertAsync(ctx, target, appLookupParams, distCert, distributionType) {
        log_1.default.log(`Setting up ${appLookupParams.projectName} to use Distribution Certificate`);
        log_1.default.log(`Creating provisioning profile...`);
        if (distributionType === generated_1.IosDistributionType.AdHoc) {
            return await new SetUpAdhocProvisioningProfile_1.SetUpAdhocProvisioningProfile({
                app: appLookupParams,
                target,
            }).runWithDistributionCertificateAsync(ctx, distCert);
        }
        else {
            return await new SetUpProvisioningProfile_1.SetUpProvisioningProfile(appLookupParams, target, distributionType).createAndAssignProfileAsync(ctx, distCert);
        }
    }
    async selectTargetAsync(targets) {
        if (targets.length === 1) {
            return targets[0];
        }
        return await (0, prompts_1.selectAsync)('Which target do you want to use?', targets.map(target => ({
            title: `${target.targetName} (Bundle Identifier: ${target.bundleIdentifier})`,
            value: target,
        })));
    }
}
exports.ManageIos = ManageIos;
