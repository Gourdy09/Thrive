"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SetUpBuildCredentialsFromCredentialsJson = void 0;
const tslib_1 = require("tslib");
const DownloadKeystore_1 = require("./DownloadKeystore");
const generated_1 = require("../../../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../../../log"));
const prompts_1 = require("../../../prompts");
const read_1 = require("../../credentialsJson/read");
const SelectAndroidBuildCredentials_1 = require("../../manager/SelectAndroidBuildCredentials");
const keystoreNew_1 = require("../utils/keystoreNew");
class SetUpBuildCredentialsFromCredentialsJson {
    constructor(app) {
        this.app = app;
    }
    async runAsync(ctx) {
        if (ctx.nonInteractive) {
            throw new Error('Setting up build credentials from credentials.json is only available in interactive mode');
        }
        let localCredentials;
        try {
            localCredentials = await (0, read_1.readAndroidCredentialsAsync)(ctx.projectDir);
        }
        catch (error) {
            log_1.default.error('Reading credentials from credentials.json failed. Make sure this file is correct and all credentials are present there.');
            throw error;
        }
        const selectBuildCredentialsResult = await new SelectAndroidBuildCredentials_1.SelectAndroidBuildCredentials(this.app).runAsync(ctx);
        if (selectBuildCredentialsResult.resultType ===
            SelectAndroidBuildCredentials_1.SelectAndroidBuildCredentialsResultType.EXISTING_CREDENTIALS &&
            selectBuildCredentialsResult.result.androidKeystore) {
            const buildCredentials = selectBuildCredentialsResult.result;
            const confirmOverwrite = await (0, prompts_1.confirmAsync)({
                message: `The build configuration ${buildCredentials.name} already has a keystore configured. Overwrite?`,
            });
            if (!confirmOverwrite) {
                return null;
            }
            await new DownloadKeystore_1.BackupKeystore(this.app).runAsync(ctx, buildCredentials);
        }
        const providedKeystoreWithType = (0, keystoreNew_1.getKeystoreWithType)(localCredentials.keystore);
        if (providedKeystoreWithType.type === generated_1.AndroidKeystoreType.Unknown) {
            const confirmKeystoreIsSketchy = await (0, prompts_1.confirmAsync)({
                message: `The keystore you provided could not be parsed and may be corrupt. Proceed anyway?`,
            });
            if (!confirmKeystoreIsSketchy) {
                return null;
            }
        }
        const keystoreFragment = await ctx.android.createKeystoreAsync(ctx.graphqlClient, this.app.account, providedKeystoreWithType);
        let buildCredentials;
        if (selectBuildCredentialsResult.resultType ===
            SelectAndroidBuildCredentials_1.SelectAndroidBuildCredentialsResultType.CREATE_REQUEST) {
            buildCredentials = await ctx.android.createAndroidAppBuildCredentialsAsync(ctx.graphqlClient, this.app, {
                ...selectBuildCredentialsResult.result,
                androidKeystoreId: keystoreFragment.id,
            });
        }
        else {
            buildCredentials = await ctx.android.updateAndroidAppBuildCredentialsAsync(ctx.graphqlClient, selectBuildCredentialsResult.result, {
                androidKeystoreId: keystoreFragment.id,
            });
        }
        log_1.default.succeed('Keystore updated');
        return buildCredentials;
    }
}
exports.SetUpBuildCredentialsFromCredentialsJson = SetUpBuildCredentialsFromCredentialsJson;
