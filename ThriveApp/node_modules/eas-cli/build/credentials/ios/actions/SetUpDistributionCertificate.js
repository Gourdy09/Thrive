"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SetUpDistributionCertificate = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const AppleTeamUtils_1 = require("./AppleTeamUtils");
const CreateDistributionCertificate_1 = require("./CreateDistributionCertificate");
const DistributionCertificateUtils_1 = require("./DistributionCertificateUtils");
const log_1 = tslib_1.__importDefault(require("../../../log"));
const prompts_1 = require("../../../prompts");
const sortBy_1 = tslib_1.__importDefault(require("../../../utils/expodash/sortBy"));
const errors_1 = require("../../errors");
const CredentialsUtils_1 = require("../appstore/CredentialsUtils");
const errors_2 = require("../errors");
class SetUpDistributionCertificate {
    constructor(app, distributionType) {
        this.app = app;
        this.distributionType = distributionType;
    }
    async runAsync(ctx) {
        const appleTeam = await (0, AppleTeamUtils_1.resolveAppleTeamIfAuthenticatedAsync)(ctx, this.app);
        try {
            const currentCertificate = await ctx.ios.getDistributionCertificateForAppAsync(ctx.graphqlClient, this.app, this.distributionType, { appleTeam });
            if (ctx.nonInteractive) {
                return await this.runNonInteractiveAsync(ctx, currentCertificate);
            }
            else {
                return await this.runInteractiveAsync(ctx, currentCertificate);
            }
        }
        catch (err) {
            if (err instanceof errors_2.AppleTeamMissingError && ctx.nonInteractive) {
                throw new errors_1.MissingCredentialsNonInteractiveError();
            }
            throw err;
        }
    }
    async runNonInteractiveAsync(_ctx, currentCertificate) {
        // TODO: implement validation
        log_1.default.addNewLineIfNone();
        log_1.default.warn('Distribution Certificate is not validated for non-interactive builds.');
        if (!currentCertificate) {
            throw new errors_1.MissingCredentialsNonInteractiveError();
        }
        return currentCertificate;
    }
    async runInteractiveAsync(ctx, currentCertificate) {
        if (await this.isCurrentCertificateValidAsync(ctx, currentCertificate)) {
            (0, assert_1.default)(currentCertificate, 'currentCertificate is defined here');
            return currentCertificate;
        }
        const validDistCertsOnFile = await this.getValidDistCertsAsync(ctx);
        return validDistCertsOnFile.length === 0
            ? await this.createNewDistCertAsync(ctx)
            : await this.createOrReuseDistCertAsync(ctx);
    }
    async isCurrentCertificateValidAsync(ctx, currentCertificate) {
        if (!currentCertificate) {
            return false;
        }
        const now = new Date();
        if (now < new Date(currentCertificate.validityNotBefore) ||
            now > new Date(currentCertificate.validityNotAfter)) {
            return false;
        }
        if (!ctx.appStore.authCtx) {
            log_1.default.warn("Skipping Distribution Certificate validation on Apple Servers because we aren't authenticated.");
            return true;
        }
        const validCertSerialNumbers = (await this.getValidDistCertsAsync(ctx)).map(i => i.serialNumber);
        const isValid = validCertSerialNumbers.includes(currentCertificate.serialNumber);
        if (!isValid) {
            log_1.default.warn('Current distribution certificate is no longer valid in Apple Dev Portal');
        }
        return isValid;
    }
    async createOrReuseDistCertAsync(ctx) {
        const validDistCerts = await this.getValidDistCertsAsync(ctx);
        const autoselectedDistCert = validDistCerts[0];
        const useAutoselected = await (0, prompts_1.confirmAsync)({
            message: `Reuse this distribution certificate?\n${(0, DistributionCertificateUtils_1.formatDistributionCertificate)(autoselectedDistCert)}`,
        });
        if (useAutoselected) {
            log_1.default.log(`Using distribution certificate with serial number ${autoselectedDistCert.serialNumber}`);
            return autoselectedDistCert;
        }
        const { action } = await (0, prompts_1.promptAsync)({
            type: 'select',
            name: 'action',
            message: 'Select the iOS distribution certificate to use for code signing:',
            choices: [
                {
                    title: '[Choose another existing certificate] (Recommended)',
                    value: 'CHOOSE_EXISTING',
                },
                { title: '[Add a new certificate]', value: 'GENERATE' },
            ],
        });
        if (action === 'GENERATE') {
            return await this.createNewDistCertAsync(ctx);
        }
        else {
            return await this.reuseDistCertAsync(ctx);
        }
    }
    async createNewDistCertAsync(ctx) {
        return await new CreateDistributionCertificate_1.CreateDistributionCertificate(this.app.account).runAsync(ctx);
    }
    async reuseDistCertAsync(ctx) {
        const validDistCerts = await this.getValidDistCertsAsync(ctx);
        const { distCert } = await (0, prompts_1.promptAsync)({
            type: 'select',
            name: 'distCert',
            message: 'Select the iOS Distribution Certificate from the list:',
            choices: validDistCerts.map(distCert => ({
                title: (0, DistributionCertificateUtils_1.formatDistributionCertificate)(distCert),
                value: distCert,
            })),
        });
        return distCert;
    }
    async getValidDistCertsAsync(ctx) {
        if (this.validDistCerts) {
            return this.validDistCerts;
        }
        const validDistCertSerialNumbers = (0, CredentialsUtils_1.getValidCertSerialNumbers)(await ctx.appStore.listDistributionCertificatesAsync());
        const validDistCertSerialNumberSet = new Set(validDistCertSerialNumbers);
        const distCertsForAccount = await ctx.ios.getDistributionCertificatesForAccountAsync(ctx.graphqlClient, this.app.account);
        const distCertsForAppleTeam = distCertsForAccount.filter(distCert => {
            return (!distCert.appleTeam ||
                distCert.appleTeam.appleTeamIdentifier === ctx.appStore.authCtx?.team.id);
        });
        const validDistCerts = distCertsForAppleTeam.filter(distCert => {
            return validDistCertSerialNumberSet.has(distCert.serialNumber);
        });
        this.validDistCerts = (0, sortBy_1.default)(validDistCerts, 'validityNotAfter', 'desc');
        return this.validDistCerts;
    }
}
exports.SetUpDistributionCertificate = SetUpDistributionCertificate;
