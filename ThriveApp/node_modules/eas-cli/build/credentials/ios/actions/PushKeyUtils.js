"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatPushKey = exports.sortPushKeys = exports.getValidAndTrackedPushKeysOnEasServersAsync = exports.selectPushKeyAsync = exports.provideOrGeneratePushKeyAsync = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const AppleTeamFormatting_1 = require("./AppleTeamFormatting");
const log_1 = tslib_1.__importStar(require("../../../log"));
const prompts_1 = require("../../../prompts");
const date_1 = require("../../../utils/date");
const promptForCredentials_1 = require("../../utils/promptForCredentials");
const CredentialsUtils_1 = require("../appstore/CredentialsUtils");
const pushKey_1 = require("../appstore/pushKey");
const credentials_1 = require("../credentials");
const validatePushKey_1 = require("../validators/validatePushKey");
async function provideOrGeneratePushKeyAsync(ctx) {
    if (!ctx.nonInteractive) {
        const userProvided = await promptForPushKeyAsync(ctx);
        if (userProvided) {
            if (!ctx.appStore.authCtx) {
                log_1.default.warn('Unable to validate push key, you are not authenticated with Apple.');
                return userProvided;
            }
            else {
                const isValidAndTracked = await (0, validatePushKey_1.isPushKeyValidAndTrackedAsync)(ctx, userProvided);
                if (isValidAndTracked) {
                    return userProvided;
                }
                // user could've just input the id wrong, and the p8 could still be valid
                const useUserProvided = await (0, prompts_1.confirmAsync)({
                    message: `Push Key with ID ${userProvided.apnsKeyId} could not be found on Apple's servers. Proceed anyway?`,
                });
                if (useUserProvided) {
                    return userProvided;
                }
                return await provideOrGeneratePushKeyAsync(ctx);
            }
        }
    }
    return await generatePushKeyAsync(ctx);
}
exports.provideOrGeneratePushKeyAsync = provideOrGeneratePushKeyAsync;
async function promptForPushKeyAsync(ctx) {
    let initialValues = {};
    if (ctx.appStore.authCtx) {
        initialValues = {
            teamId: ctx.appStore.authCtx.team.id,
        };
    }
    const userProvided = await (0, promptForCredentials_1.askForUserProvidedAsync)(credentials_1.pushKeySchema, initialValues);
    if (!userProvided) {
        return null;
    }
    if (ctx.appStore.authCtx && userProvided.teamId === initialValues.teamId) {
        return {
            ...userProvided,
            teamName: ctx.appStore.authCtx.team.name,
        };
    }
    return userProvided;
}
async function generatePushKeyAsync(ctx) {
    await ctx.appStore.ensureAuthenticatedAsync();
    try {
        return await ctx.appStore.createPushKeyAsync();
    }
    catch (e) {
        if (e.message === pushKey_1.APPLE_KEYS_TOO_MANY_GENERATED_ERROR) {
            const pushKeys = await ctx.appStore.listPushKeysAsync();
            log_1.default.warn('Maximum number of Push Notifications Keys generated on Apple Developer Portal.');
            log_1.default.warn(pushKey_1.APPLE_KEYS_TOO_MANY_GENERATED_ERROR);
            if (ctx.nonInteractive) {
                throw new Error("Start the CLI without the '--non-interactive' flag to revoke existing push notification keys.");
            }
            log_1.default.log(chalk_1.default.grey(`⚠️  Revoking a Push Key will affect other apps that rely on it`));
            log_1.default.log((0, log_1.learnMore)('https://docs.expo.dev/distribution/app-signing/#push-notification-keys'));
            log_1.default.log();
            const { pushKeysToRevoke } = await (0, prompts_1.promptAsync)({
                type: 'multiselect',
                name: 'pushKeysToRevoke',
                message: 'Select Push Notifications Key to revoke.',
                // @ts-expect-error property missing from `@types/prompts`
                optionsPerPage: 20,
                choices: pushKeys.map(pushKey => ({
                    value: pushKey,
                    title: formatPushKeyFromApple(pushKey),
                })),
            });
            if (pushKeysToRevoke.length > 0) {
                const ids = pushKeysToRevoke.map(({ id }) => id);
                await ctx.appStore.revokePushKeyAsync(ids);
            }
        }
        else {
            throw e;
        }
    }
    return await generatePushKeyAsync(ctx);
}
function formatPushKeyFromApple(pushKey) {
    const { name, id } = pushKey;
    const keyIdText = id ? ` - Key ID: ${id}` : ``;
    return `${name}${keyIdText}`;
}
/**
 * select a push key from an account (validity status shown on a best effort basis)
 * */
async function selectPushKeyAsync(ctx, account) {
    const pushKeysForAccount = await ctx.ios.getPushKeysForAccountAsync(ctx.graphqlClient, account);
    if (pushKeysForAccount.length === 0) {
        log_1.default.warn(`There are no Push Keys available in your EAS account.`);
        return null;
    }
    if (!ctx.appStore.authCtx) {
        return await selectPushKeysAsync(pushKeysForAccount);
    }
    const validPushKeys = await getValidAndTrackedPushKeysOnEasServersAsync(ctx, pushKeysForAccount);
    return await selectPushKeysAsync(pushKeysForAccount, validPushKeys);
}
exports.selectPushKeyAsync = selectPushKeyAsync;
async function getValidAndTrackedPushKeysOnEasServersAsync(ctx, pushKeysForAccount) {
    const pushInfoFromApple = await ctx.appStore.listPushKeysAsync();
    return await (0, CredentialsUtils_1.filterRevokedAndUntrackedPushKeysFromEasServersAsync)(pushKeysForAccount, pushInfoFromApple);
}
exports.getValidAndTrackedPushKeysOnEasServersAsync = getValidAndTrackedPushKeysOnEasServersAsync;
async function selectPushKeysAsync(pushKeys, validPushKeys) {
    const validPushKeyIdentifiers = validPushKeys?.map(pushKey => pushKey.keyIdentifier);
    const sortedPushKeys = sortPushKeys(pushKeys, validPushKeys);
    const { chosenPushKey } = await (0, prompts_1.promptAsync)({
        type: 'select',
        name: 'chosenPushKey',
        message: 'Select a push key from the list.',
        choices: sortedPushKeys.map(pushKey => ({
            title: formatPushKey(pushKey, validPushKeyIdentifiers),
            value: pushKey,
        })),
    });
    return chosenPushKey;
}
function sortPushKeys(pushKeys, validPushKeys) {
    const validPushKeyIdentifiers = validPushKeys?.map(pushKey => pushKey.keyIdentifier);
    return pushKeys.sort((pushKeyA, pushKeyB) => {
        if (validPushKeyIdentifiers?.includes(pushKeyA.keyIdentifier)) {
            return -1;
        }
        else if (validPushKeyIdentifiers?.includes(pushKeyB.keyIdentifier)) {
            return 1;
        }
        return 0;
    });
}
exports.sortPushKeys = sortPushKeys;
function formatPushKey(pushKey, validPushKeyIdentifiers) {
    const { keyIdentifier, appleTeam, updatedAt } = pushKey;
    let line = '';
    line += `Push Key ID: ${pushKey.keyIdentifier}`;
    line += ` ${appleTeam ? `, ${(0, AppleTeamFormatting_1.formatAppleTeam)(appleTeam)}` : ''}`;
    line += chalk_1.default.gray(`\n    Updated: ${(0, date_1.fromNow)(new Date(updatedAt))} ago,`);
    const apps = pushKey.iosAppCredentialsList.map(appCredentials => appCredentials.app);
    if (apps.length) {
        // iosAppCredentialsList is capped at 20 on www
        const appFullNames = apps
            .map(app => app.fullName)
            .slice(0, 19)
            .join(',');
        const andMaybeMore = apps.length > 19 ? ' (and more)' : '';
        line += chalk_1.default.gray(`\n    📲 Used by: ${appFullNames}${andMaybeMore}`);
    }
    if (validPushKeyIdentifiers?.includes(keyIdentifier)) {
        line += chalk_1.default.gray("\n    ✅ Currently valid on Apple's servers.");
    }
    else {
        line += '';
    }
    return line;
}
exports.formatPushKey = formatPushKey;
