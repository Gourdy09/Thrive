"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncCapabilityIdentifiersForEntitlementsAsync = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const bundleIdCapabilities_1 = require("./bundleIdCapabilities");
const log_1 = tslib_1.__importDefault(require("../../../log"));
const authType_1 = require("../utils/authType");
/**
 * Sync the capability identifiers with the bundle identifier capabilities.
 * If a capability identifier is missing, then attempt to create it.
 * Link all of the capability identifiers at the same time after parsing the entitlements file.
 *
 * **Does not support App Store Connect API (CI).**
 *
 * @param bundleId Bundle identifier object.
 * @param entitlements JSON representation of the iOS entitlements plist
 *
 * @returns an object specifying the capabilities that were linked, and created.
 */
async function syncCapabilityIdentifiersForEntitlementsAsync(bundleId, entitlements = {}) {
    if (bundleIdCapabilities_1.EXPO_NO_CAPABILITY_SYNC) {
        return { created: [], linked: [] };
    }
    // App Store Connect token authentication is not currently supported,
    // the team ID is required to create capability identifiers.
    if ((0, authType_1.isAppStoreConnectTokenOnlyContext)(bundleId.context)) {
        log_1.default.warn(`Skipping capability identifier syncing because the current Apple authentication session is not using Cookies (username/password).`);
        return { created: [], linked: [] };
    }
    const createdIds = [];
    const linkedIds = [];
    const CapabilityIdMapping = bundleIdCapabilities_1.CapabilityMapping.filter(capability => capability.capabilityIdModel);
    const updateRequest = [];
    // Iterate through the supported capabilities to build the request.
    for (const classifier of CapabilityIdMapping) {
        const CapabilityModel = classifier.capabilityIdModel;
        // Skip capabilities that don't support capability IDs.
        if (!CapabilityModel) {
            continue;
        }
        const validate = (value) => {
            if (!value) {
                return false;
            }
            (0, bundleIdCapabilities_1.assertValidOptions)(classifier, value);
            return true;
        };
        // Skip capabilities that aren't defined in the entitlements file.
        const entitlementValue = entitlements[classifier.entitlement];
        if (!validate(entitlementValue)) {
            continue;
        }
        // Remove any duplicates to cut down on network requests
        const capabilityIds = [...new Set(entitlementValue)];
        // Get a list of all of the capability IDs that are already created on the server.
        const existingIds = await CapabilityModel.getAsync(bundleId.context);
        // A list of server IDs for linking.
        const capabilityIdOpaqueIds = [];
        // Iterate through all the local IDs and see if they exist on the server.
        for (const localId of capabilityIds) {
            let remoteIdModel = existingIds.find(model => model.attributes.identifier === localId);
            // If a remote ID exists, then create it.
            if (!remoteIdModel) {
                if (log_1.default.isDebug) {
                    log_1.default.log(`Creating capability ID: ${localId} (${CapabilityModel.type})`);
                }
                try {
                    remoteIdModel = await CapabilityModel.createAsync(bundleId.context, {
                        identifier: localId,
                    });
                }
                catch (error) {
                    // Add a more helpful error message.
                    error.message += `\n\nRemove the value '${localId}' from the array '${classifier.entitlement}' in the iOS project entitlements.\nIf you know that the ID is registered to one of your apps, try again with a different Apple account.`;
                    throw error;
                }
                // Create a list of newly created IDs for displaying in the CLI.
                createdIds.push(localId);
                if (log_1.default.isDebug) {
                    log_1.default.log(`Created capability ID: ${remoteIdModel.id}`);
                }
            }
            if (log_1.default.isDebug) {
                log_1.default.log(`Linking ID to ${CapabilityModel.type}: ${localId} (${remoteIdModel.id})`);
            }
            // Create a list of linked IDs for displaying in the CLI.
            linkedIds.push(remoteIdModel.attributes.identifier);
            capabilityIdOpaqueIds.push(remoteIdModel.id);
        }
        updateRequest.push({
            capabilityType: classifier.capability,
            option: apple_utils_1.CapabilityTypeOption.ON,
            relationships: {
                // One of: `merchantIds`, `appGroups`, `cloudContainers`.
                [CapabilityModel.type]: capabilityIdOpaqueIds,
            },
        });
    }
    if (updateRequest.length) {
        if (log_1.default.isDebug) {
            log_1.default.log(`Updating bundle identifier with capability identifiers:`, updateRequest);
        }
        await bundleId.updateBundleIdCapabilityAsync(updateRequest);
    }
    else if (log_1.default.isDebug) {
        log_1.default.log(`No capability identifiers need to be updated`);
    }
    return { created: createdIds, linked: linkedIds };
}
exports.syncCapabilityIdentifiersForEntitlementsAsync = syncCapabilityIdentifiersForEntitlementsAsync;
