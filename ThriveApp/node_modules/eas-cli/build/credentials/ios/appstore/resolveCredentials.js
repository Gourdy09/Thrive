"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deletePasswordAsync = exports.promptPasswordAsync = exports.resolveAppleTeamAsync = exports.resolveAscApiKeyAsync = exports.hasAscEnvVars = exports.resolveUserCredentialsAsync = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs = tslib_1.__importStar(require("fs-extra"));
const wrap_ansi_1 = tslib_1.__importDefault(require("wrap-ansi"));
const authenticateTypes_1 = require("./authenticateTypes");
const Keychain = tslib_1.__importStar(require("./keychain"));
const log_1 = tslib_1.__importStar(require("../../../log"));
const prompts_1 = require("../../../prompts");
/**
 * Get the username and possibly the password from the environment variables or the supplied options.
 * Password is optional because it's only needed for authentication, but not for re-authentication.
 *
 * @param options
 */
async function resolveUserCredentialsAsync(options) {
    const credentials = getAppleIdFromEnvironmentOrOptions(options);
    if (!credentials.username) {
        credentials.username = await promptUsernameAsync();
    }
    return credentials;
}
exports.resolveUserCredentialsAsync = resolveUserCredentialsAsync;
function hasAscEnvVars() {
    return (!!process.env.EXPO_ASC_API_KEY_PATH ||
        !!process.env.EXPO_ASC_KEY_ID ||
        !!process.env.EXPO_ASC_ISSUER_ID);
}
exports.hasAscEnvVars = hasAscEnvVars;
async function resolveAscApiKeyAsync(ascApiKey) {
    const passedKeyP8 = await getAscKeyP8FromEnvironmentOrOptionsAsync(ascApiKey);
    const passedKeyId = await getAscKeyIdFromEnvironmentOrOptionsAsync(ascApiKey);
    const passedIssuerId = await getAscIssuerIdFromEnvironmentOrOptionsAsync(ascApiKey);
    return {
        keyP8: passedKeyP8,
        keyId: passedKeyId,
        issuerId: passedIssuerId,
    };
}
exports.resolveAscApiKeyAsync = resolveAscApiKeyAsync;
async function getAscKeyP8FromEnvironmentOrOptionsAsync(ascApiKey) {
    if (ascApiKey?.keyP8) {
        return ascApiKey?.keyP8;
    }
    else if (process.env.EXPO_ASC_API_KEY_PATH) {
        return await fs.readFile(process.env.EXPO_ASC_API_KEY_PATH, 'utf-8');
    }
    const { ascApiKeyPath } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'ascApiKeyPath',
        message: `Path to ASC Api Key Path (.p8):`,
        validate: (val) => val !== '',
    });
    return await fs.readFile(ascApiKeyPath, 'utf-8');
}
async function getAscKeyIdFromEnvironmentOrOptionsAsync(ascApiKey) {
    if (ascApiKey?.keyId) {
        return ascApiKey?.keyId;
    }
    else if (process.env.EXPO_ASC_KEY_ID) {
        return process.env.EXPO_ASC_KEY_ID;
    }
    const { ascApiKeyId } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'ascApiKeyId',
        message: `ASC Api Key ID:`,
        validate: (val) => val !== '',
    });
    return ascApiKeyId;
}
async function getAscIssuerIdFromEnvironmentOrOptionsAsync(ascApiKey) {
    if (ascApiKey?.issuerId) {
        return ascApiKey?.issuerId;
    }
    else if (process.env.EXPO_ASC_ISSUER_ID) {
        return process.env.EXPO_ASC_ISSUER_ID;
    }
    const { ascIssuerId } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'ascIssuerId',
        message: `ASC Issuer ID:`,
        validate: (val) => val !== '',
    });
    return ascIssuerId;
}
function isAppleTeamType(maybeTeamType) {
    return maybeTeamType in authenticateTypes_1.AppleTeamType;
}
function assertAppleTeamType(maybeTeamType) {
    if (!isAppleTeamType(maybeTeamType)) {
        throw new Error(`Invalid Apple Team Type: ${maybeTeamType}. Must be one of ${Object.keys(authenticateTypes_1.AppleTeamType).join(', ')}`);
    }
    return maybeTeamType;
}
function resolveAppleTeamTypeFromEnvironment() {
    if (!process.env.EXPO_APPLE_TEAM_TYPE) {
        return undefined;
    }
    return assertAppleTeamType(process.env.EXPO_APPLE_TEAM_TYPE);
}
async function getAppleTeamIdFromEnvironmentOrOptionsAsync(options) {
    if (options.teamId) {
        return options.teamId;
    }
    else if (process.env.EXPO_APPLE_TEAM_ID) {
        return process.env.EXPO_APPLE_TEAM_ID;
    }
    const { appleTeamId } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'appleTeamId',
        message: `Apple Team ID:`,
        validate: (val) => val !== '',
    });
    return appleTeamId;
}
async function getAppleTeamTypeFromEnvironmentOrOptionsAsync(options) {
    if (options.teamType) {
        return options.teamType;
    }
    const appleTeamTypeFromEnvironment = resolveAppleTeamTypeFromEnvironment();
    if (appleTeamTypeFromEnvironment) {
        return appleTeamTypeFromEnvironment;
    }
    const { appleTeamType } = await (0, prompts_1.promptAsync)({
        type: 'select',
        message: 'Select your Apple Team Type:',
        name: 'appleTeamType',
        choices: [
            { title: 'Enterprise', value: authenticateTypes_1.AppleTeamType.IN_HOUSE },
            { title: 'Company/Organization', value: authenticateTypes_1.AppleTeamType.COMPANY_OR_ORGANIZATION },
            { title: 'Individual', value: authenticateTypes_1.AppleTeamType.INDIVIDUAL },
        ],
    });
    return appleTeamType;
}
async function resolveAppleTeamAsync(options = {}) {
    const passedTeamType = await getAppleTeamTypeFromEnvironmentOrOptionsAsync(options);
    return {
        id: await getAppleTeamIdFromEnvironmentOrOptionsAsync(options),
        name: options.teamName,
        inHouse: passedTeamType === authenticateTypes_1.AppleTeamType.IN_HOUSE,
    };
}
exports.resolveAppleTeamAsync = resolveAppleTeamAsync;
function getAppleIdFromEnvironmentOrOptions({ username, password, ...userCredentials }) {
    const passedAppleId = username || process.env.EXPO_APPLE_ID;
    // Only resolve the password if the username was provided.
    const passedAppleIdPassword = passedAppleId
        ? password || process.env.EXPO_APPLE_PASSWORD
        : undefined;
    return {
        ...userCredentials,
        username: passedAppleId,
        password: passedAppleIdPassword,
    };
}
async function promptUsernameAsync() {
    log_1.default.log('\u203A Log in to your Apple Developer account to continue');
    // Get the email address that was last used and set it as
    // the default value for quicker authentication.
    const lastAppleId = await getCachedUsernameAsync();
    const { username } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'username',
        message: `Apple ID:`,
        validate: (val) => val !== '',
        initial: lastAppleId ?? undefined,
    });
    if (username && username !== lastAppleId) {
        await cacheUsernameAsync(username);
    }
    return username;
}
async function cacheUsernameAsync(username) {
    // If a new email was used then store it as a suggestion for next time.
    // This functionality is disabled using the keychain mechanism.
    if (!Keychain.EXPO_NO_KEYCHAIN && username) {
        const cachedPath = apple_utils_1.JsonFileCache.usernameCachePath();
        await apple_utils_1.JsonFileCache.cacheAsync(cachedPath, { username });
    }
}
async function promptPasswordAsync({ username, }) {
    const cachedPassword = await getCachedPasswordAsync({ username });
    if (cachedPassword) {
        log_1.default.log(`\u203A Using password for ${username} from your local Keychain`);
        log_1.default.log(`  ${(0, log_1.learnMore)('https://docs.expo.dev/distribution/security#keychain')}`);
        return cachedPassword;
    }
    // https://docs.expo.dev/distribution/security/#apple-developer-account-credentials
    log_1.default.log((0, wrap_ansi_1.default)(chalk_1.default.bold(`\u203A The password is only used to authenticate with Apple and never stored on EAS servers`), process.stdout.columns || 80));
    log_1.default.log(`  ${(0, log_1.learnMore)('https://bit.ly/2VtGWhU')}`);
    const { password } = await (0, prompts_1.promptAsync)({
        type: 'password',
        name: 'password',
        message: () => `Password (for ${username}):`,
        validate: (val) => val !== '',
    });
    // TODO: Save only after the auth completes successfully.
    await cachePasswordAsync({ username, password });
    return password;
}
exports.promptPasswordAsync = promptPasswordAsync;
async function getCachedUsernameAsync() {
    if (Keychain.EXPO_NO_KEYCHAIN) {
        // Clear last used apple ID.
        await fs.remove(apple_utils_1.JsonFileCache.usernameCachePath());
        return null;
    }
    const cached = await apple_utils_1.JsonFileCache.getCacheAsync(apple_utils_1.JsonFileCache.usernameCachePath());
    const lastAppleId = cached?.username ?? null;
    return typeof lastAppleId === 'string' ? lastAppleId : null;
}
/**
 * Returns the same prefix used by Fastlane in order to potentially share access between services.
 * [Cite. Fastlane](https://github.com/fastlane/fastlane/blob/f831062fa6f4b216b8ee38949adfe28fc11a0a8e/credentials_manager/lib/credentials_manager/account_manager.rb#L8).
 *
 * @param appleId email address
 */
function getKeychainServiceName(appleId) {
    return `deliver.${appleId}`;
}
async function deletePasswordAsync({ username, }) {
    const serviceName = getKeychainServiceName(username);
    const success = await Keychain.deletePasswordAsync({ username, serviceName });
    if (success) {
        log_1.default.log('\u203A Removed Apple ID password from the native Keychain');
    }
    return success;
}
exports.deletePasswordAsync = deletePasswordAsync;
async function getCachedPasswordAsync({ username, }) {
    // If the user opts out, delete the password.
    if (Keychain.EXPO_NO_KEYCHAIN) {
        await deletePasswordAsync({ username });
        return null;
    }
    const serviceName = getKeychainServiceName(username);
    return await Keychain.getPasswordAsync({ username, serviceName });
}
async function cachePasswordAsync({ username, password }) {
    if (Keychain.EXPO_NO_KEYCHAIN) {
        log_1.default.log('\u203A Skip storing Apple ID password in the local Keychain.');
        return false;
    }
    log_1.default.log(`\u203A Saving Apple ID password to the local Keychain`);
    log_1.default.log(`  ${(0, log_1.learnMore)('https://docs.expo.dev/distribution/security#keychain')}`);
    const serviceName = getKeychainServiceName(username);
    return await Keychain.setPasswordAsync({ username, password, serviceName });
}
