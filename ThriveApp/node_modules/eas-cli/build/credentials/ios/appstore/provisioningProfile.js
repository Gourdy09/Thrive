"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.revokeProvisioningProfileAsync = exports.createProvisioningProfileAsync = exports.listProvisioningProfilesAsync = exports.useExistingProvisioningProfileAsync = exports.ProfileClass = void 0;
const apple_utils_1 = require("@expo/apple-utils");
const authenticate_1 = require("./authenticate");
const bundleId_1 = require("./bundleId");
const constants_1 = require("./constants");
const distributionCertificate_1 = require("./distributionCertificate");
const ora_1 = require("../../../ora");
const authType_1 = require("../utils/authType");
const p12Certificate_1 = require("../utils/p12Certificate");
var ProfileClass;
(function (ProfileClass) {
    ProfileClass["Adhoc"] = "ad_hoc";
    ProfileClass["General"] = "general";
})(ProfileClass || (exports.ProfileClass = ProfileClass = {}));
function resolveProfileType(applePlatform, profileClass, isEnterprise) {
    switch (applePlatform) {
        case constants_1.ApplePlatform.IOS:
            return resolveProfileTypeIos(profileClass, isEnterprise);
        case constants_1.ApplePlatform.TV_OS:
            return resolveProfileTypeAppleTv(profileClass, isEnterprise);
        case constants_1.ApplePlatform.MAC_OS:
            throw new Error(`${applePlatform} profiles are not supported`);
    }
}
function resolveProfileTypeAppleTv(profileClass, isEnterprise) {
    if (isEnterprise) {
        return profileClass === ProfileClass.Adhoc
            ? apple_utils_1.ProfileType.TVOS_APP_ADHOC
            : apple_utils_1.ProfileType.TVOS_APP_INHOUSE;
    }
    else {
        return profileClass === ProfileClass.Adhoc
            ? apple_utils_1.ProfileType.TVOS_APP_ADHOC
            : apple_utils_1.ProfileType.TVOS_APP_STORE;
    }
}
function resolveProfileTypeIos(profileClass, isEnterprise) {
    if (isEnterprise) {
        return profileClass === ProfileClass.Adhoc
            ? apple_utils_1.ProfileType.IOS_APP_ADHOC
            : apple_utils_1.ProfileType.IOS_APP_INHOUSE;
    }
    else {
        return profileClass === ProfileClass.Adhoc
            ? apple_utils_1.ProfileType.IOS_APP_ADHOC
            : apple_utils_1.ProfileType.IOS_APP_STORE;
    }
}
async function transformProfileAsync(cert, authCtx) {
    return {
        provisioningProfileId: cert.id,
        name: cert.attributes.name,
        status: cert.attributes.profileState,
        expires: new Date(cert.attributes.expirationDate).getTime() / 1000,
        distributionMethod: cert.attributes.profileType,
        // @ts-expect-error -- this can be null when the profile has expired.
        provisioningProfile: cert.attributes.profileContent,
        certificates: (await cert.getCertificatesAsync()).map(distributionCertificate_1.transformCertificate),
        teamId: authCtx.team.id,
        teamName: authCtx.team.name,
    };
}
async function addCertificateToProfileAsync(context, { serialNumber, profileId, bundleIdentifier, }) {
    const cert = await (0, distributionCertificate_1.getCertificateBySerialNumberAsync)(context, serialNumber);
    const profiles = await (0, bundleId_1.getProfilesForBundleIdAsync)(context, bundleIdentifier);
    const profile = profiles.find(profile => profile.id === profileId);
    if (!profile) {
        throw new Error(`Failed to find profile for bundle identifier "${bundleIdentifier}" with profile id "${profileId}"`);
    }
    // Assign the new certificate
    profile.attributes.certificates = [cert];
    // Experimentally regenerate the provisioning profile using App Store Connect API.
    if ((0, authType_1.isAppStoreConnectTokenOnlyContext)(profile.context)) {
        return await profile.regenerateManuallyAsync();
    }
    // This method does not support App Store Connect API.
    return await profile.regenerateAsync();
}
async function useExistingProvisioningProfileAsync(authCtx, bundleIdentifier, provisioningProfile, distCert) {
    if (!provisioningProfile.provisioningProfileId) {
        throw new Error('Provisioning profile: cannot use existing profile, insufficient id');
    }
    const certIdTag = distCert.certId ? ` (${distCert.certId})` : '';
    const spinner = (0, ora_1.ora)(`Updating provisioning profile (${provisioningProfile.provisioningProfileId}) with distribution certificate${certIdTag}`).start();
    try {
        if (!distCert.distCertSerialNumber) {
            distCert.distCertSerialNumber = (0, p12Certificate_1.findP12CertSerialNumber)(distCert.certP12, distCert.certPassword);
        }
        const context = (0, authenticate_1.getRequestContext)(authCtx);
        const profile = await addCertificateToProfileAsync(context, {
            serialNumber: distCert.distCertSerialNumber,
            profileId: provisioningProfile.provisioningProfileId,
            bundleIdentifier,
        });
        const content = profile.attributes.profileContent;
        if (!content) {
            // this should never happen because of the regen.
            throw new Error(`Provisioning profile "${profile.attributes.name}" (${profile.id}) is expired!`);
        }
        const result = {
            provisioningProfileId: profile.id,
            provisioningProfile: content,
            teamId: authCtx.team.id,
            teamName: authCtx.team.name,
        };
        spinner.succeed(`Updated provisioning profile (${profile.id}) with distribution certificate${certIdTag}`);
        return {
            ...result,
            teamId: authCtx.team.id,
            teamName: authCtx.team.name,
        };
    }
    catch (error) {
        spinner.fail(`Failed to update provisioning profile (${provisioningProfile.provisioningProfileId}) with distribution certificate${certIdTag}`);
        throw error;
    }
}
exports.useExistingProvisioningProfileAsync = useExistingProvisioningProfileAsync;
async function listProvisioningProfilesAsync(authCtx, bundleIdentifier, applePlatform, profileClass = ProfileClass.General) {
    const spinner = (0, ora_1.ora)(`Fetching Apple provisioning profiles`).start();
    try {
        const context = (0, authenticate_1.getRequestContext)(authCtx);
        const profileType = resolveProfileType(applePlatform, profileClass, authCtx.team.inHouse);
        const profiles = (await (0, bundleId_1.getProfilesForBundleIdAsync)(context, bundleIdentifier)).filter(profile => profile.attributes.profileType === profileType);
        const result = await Promise.all(profiles.map(profile => transformProfileAsync(profile, authCtx)));
        spinner.succeed(`Fetched Apple provisioning profiles`);
        return result;
    }
    catch (error) {
        spinner.fail(`Failed to fetch Apple provisioning profiles`);
        throw error;
    }
}
exports.listProvisioningProfilesAsync = listProvisioningProfilesAsync;
async function createProvisioningProfileAsync(authCtx, bundleIdentifier, distCert, profileName, applePlatform, profileClass = ProfileClass.General) {
    const spinner = (0, ora_1.ora)(`Creating Apple provisioning profile`).start();
    try {
        if (!distCert.distCertSerialNumber) {
            distCert.distCertSerialNumber = (0, p12Certificate_1.findP12CertSerialNumber)(distCert.certP12, distCert.certPassword);
        }
        const context = (0, authenticate_1.getRequestContext)(authCtx);
        const profileType = resolveProfileType(applePlatform, profileClass, authCtx.team.inHouse);
        const certificate = await (0, distributionCertificate_1.getCertificateBySerialNumberAsync)(context, distCert.distCertSerialNumber);
        const bundleIdItem = await (0, bundleId_1.getBundleIdForIdentifierAsync)(context, bundleIdentifier);
        const profile = await apple_utils_1.Profile.createAsync(context, {
            bundleId: bundleIdItem.id,
            name: profileName,
            certificates: [certificate.id],
            devices: [],
            profileType,
        });
        const result = await transformProfileAsync(profile, authCtx);
        spinner.succeed('Created Apple provisioning profile');
        return result;
    }
    catch (error) {
        spinner.fail('Failed to create Apple provisioning profile');
        throw error;
    }
}
exports.createProvisioningProfileAsync = createProvisioningProfileAsync;
async function revokeProvisioningProfileAsync(authCtx, bundleIdentifier, applePlatform, profileClass = ProfileClass.General) {
    const spinner = (0, ora_1.ora)(`Revoking Apple provisioning profile`).start();
    try {
        const context = (0, authenticate_1.getRequestContext)(authCtx);
        const profiles = await (0, bundleId_1.getProfilesForBundleIdAsync)(context, bundleIdentifier);
        const profileType = resolveProfileType(applePlatform, profileClass, authCtx.team.inHouse);
        await Promise.all(profiles
            .filter(profile => profile.attributes.profileType === profileType)
            .map(profile => apple_utils_1.Profile.deleteAsync(context, { id: profile.id })));
        spinner.succeed('Revoked Apple provisioning profile');
    }
    catch (error) {
        spinner.fail('Failed to revoke Apple provisioning profile');
        throw error;
    }
}
exports.revokeProvisioningProfileAsync = revokeProvisioningProfileAsync;
