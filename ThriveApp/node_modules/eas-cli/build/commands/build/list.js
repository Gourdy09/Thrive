"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const queries_1 = require("../../build/queries");
const types_1 = require("../../build/types");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const pagination_1 = require("../../commandUtils/pagination");
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../../log"));
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const buildDistribution_1 = require("../../utils/buildDistribution");
const json_1 = require("../../utils/json");
class BuildList extends EasCommand_1.default {
    async runAsync() {
        const { flags } = await this.parse(_a);
        const paginatedQueryOptions = (0, pagination_1.getPaginatedQueryOptions)(flags);
        const { json: jsonFlag, platform: requestedPlatform, status: buildStatus, distribution: buildDistribution, 'non-interactive': nonInteractive, } = flags;
        if (buildDistribution === types_1.BuildDistributionType.SIMULATOR) {
            log_1.default.warn(`Using --distribution flag with "simulator" value is deprecated - use --simulator flag instead`);
        }
        if (flags.simulator && requestedPlatform !== platform_1.RequestedPlatform.Ios) {
            log_1.default.error(`The --simulator flag is only usable with --platform flag set to "ios", as it is used to filter specifically iOS simulator builds`);
            process.exit(1);
        }
        const { privateProjectConfig: { projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(_a, {
            nonInteractive,
        });
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const platform = toAppPlatform(requestedPlatform);
        const graphqlBuildStatus = toGraphQLBuildStatus(buildStatus);
        const graphqlBuildDistribution = (0, buildDistribution_1.buildDistributionTypeToGraphQLDistributionType)(buildDistribution);
        const displayName = await (0, projectUtils_1.getDisplayNameForProjectIdAsync)(graphqlClient, projectId);
        await (0, queries_1.listAndRenderBuildsOnAppAsync)(graphqlClient, {
            projectId,
            projectDisplayName: displayName,
            filter: {
                platform,
                status: graphqlBuildStatus,
                distribution: graphqlBuildDistribution,
                channel: flags.channel,
                appVersion: flags['app-version'],
                appBuildVersion: flags['app-build-version'],
                sdkVersion: flags['sdk-version'],
                runtimeVersion: flags['runtime-version'],
                appIdentifier: flags['app-identifier'],
                buildProfile: flags['build-profile'],
                gitCommitHash: flags['git-commit-hash'],
                simulator: flags.simulator,
            },
            paginatedQueryOptions,
        });
    }
}
_a = BuildList;
BuildList.description = 'list all builds for your project';
BuildList.flags = {
    platform: core_1.Flags.enum({
        options: Object.values(platform_1.RequestedPlatform),
        char: 'p',
    }),
    status: core_1.Flags.enum({
        options: Object.values(types_1.BuildStatus),
        description: 'Filter only builds with the specified status',
    }),
    distribution: core_1.Flags.enum({
        options: Object.values(types_1.BuildDistributionType),
        description: 'Filter only builds with the specified distribution type',
    }),
    channel: core_1.Flags.string(),
    'app-version': core_1.Flags.string({
        aliases: ['appVersion'],
        description: 'Filter only builds created with the specified main app version',
    }),
    'app-build-version': core_1.Flags.string({
        aliases: ['appBuildVersion'],
        description: 'Filter only builds created with the specified app build version',
    }),
    'sdk-version': core_1.Flags.string({
        aliases: ['sdkVersion'],
        description: 'Filter only builds created with the specified Expo SDK version',
    }),
    'runtime-version': core_1.Flags.string({
        aliases: ['runtimeVersion'],
        description: 'Filter only builds created with the specified runtime version',
    }),
    'app-identifier': core_1.Flags.string({
        aliases: ['appIdentifier'],
        description: 'Filter only builds created with the specified app identifier',
    }),
    'build-profile': core_1.Flags.string({
        char: 'e',
        aliases: ['profile', 'buildProfile'],
        description: 'Filter only builds created with the specified build profile',
    }),
    'git-commit-hash': core_1.Flags.string({
        aliases: ['gitCommitHash'],
        description: 'Filter only builds created with the specified git commit hash',
    }),
    ...pagination_1.EasPaginatedQueryFlags,
    limit: (0, pagination_1.getLimitFlagWithCustomValues)({ defaultTo: 10, limit: queries_1.BUILDS_LIMIT }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
    simulator: core_1.Flags.boolean({
        description: 'Filter only iOS simulator builds. Can only be used with --platform flag set to "ios"',
    }),
};
BuildList.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
    ..._a.ContextOptions.Vcs,
};
exports.default = BuildList;
const toAppPlatform = (requestedPlatform) => {
    if (!requestedPlatform || requestedPlatform === platform_1.RequestedPlatform.All) {
        return undefined;
    }
    else if (requestedPlatform === platform_1.RequestedPlatform.Android) {
        return generated_1.AppPlatform.Android;
    }
    else {
        return generated_1.AppPlatform.Ios;
    }
};
const toGraphQLBuildStatus = (buildStatus) => {
    if (!buildStatus) {
        return undefined;
    }
    else if (buildStatus === types_1.BuildStatus.NEW) {
        return generated_1.BuildStatus.New;
    }
    else if (buildStatus === types_1.BuildStatus.IN_QUEUE) {
        return generated_1.BuildStatus.InQueue;
    }
    else if (buildStatus === types_1.BuildStatus.IN_PROGRESS) {
        return generated_1.BuildStatus.InProgress;
    }
    else if (buildStatus === types_1.BuildStatus.PENDING_CANCEL) {
        return generated_1.BuildStatus.PendingCancel;
    }
    else if (buildStatus === types_1.BuildStatus.ERRORED) {
        return generated_1.BuildStatus.Errored;
    }
    else if (buildStatus === types_1.BuildStatus.FINISHED) {
        return generated_1.BuildStatus.Finished;
    }
    else {
        return generated_1.BuildStatus.Canceled;
    }
};
