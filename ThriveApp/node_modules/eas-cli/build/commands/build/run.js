"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const fs_extra_1 = require("fs-extra");
const path_1 = tslib_1.__importDefault(require("path"));
const queries_1 = require("../../build/queries");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const pagination_1 = require("../../commandUtils/pagination");
const generated_1 = require("../../graphql/generated");
const BuildQuery_1 = require("../../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const run_1 = require("../../run/run");
const utils_1 = require("../../run/utils");
const download_1 = require("../../utils/download");
const paths_1 = require("../../utils/paths");
class Run extends EasCommand_1.default {
    async runAsync() {
        const { flags: rawFlags } = await this.parse(_a);
        const flags = await this.sanitizeFlagsAsync(rawFlags);
        const queryOptions = (0, pagination_1.getPaginatedQueryOptions)(flags);
        const { loggedIn: { graphqlClient }, privateProjectConfig: { projectId }, } = await this.getContextAsync(_a, {
            nonInteractive: false,
        });
        const simulatorBuildPath = await getPathToSimulatorBuildAppAsync(graphqlClient, projectId, flags, queryOptions);
        await (0, run_1.runAsync)(simulatorBuildPath, flags.selectedPlatform);
    }
    async sanitizeFlagsAsync(flags) {
        const { platform, limit, offset, profile, ...runArchiveFlags } = flags;
        const selectedPlatform = await resolvePlatformAsync(platform);
        if (platform === 'ios' && process.platform !== 'darwin') {
            core_1.Errors.error('You can only use an iOS simulator to run apps on macOS devices', {
                exit: 1,
            });
        }
        if (runArchiveFlags.path &&
            !((runArchiveFlags.path.endsWith('.tar.gz') ||
                runArchiveFlags.path.endsWith('.app') ||
                runArchiveFlags.path.endsWith('.apk')) &&
                (await (0, fs_extra_1.pathExists)(runArchiveFlags.path)))) {
            core_1.Errors.error('The path must point to a .tar.gz archive, .apk file, or .app directory', {
                exit: 1,
            });
        }
        if (profile && (runArchiveFlags.id || runArchiveFlags.path || runArchiveFlags.url)) {
            log_1.default.warn('The --profile flag is ignored when using --id, --path, or --url flags.');
        }
        return {
            selectedPlatform,
            runArchiveFlags,
            limit,
            offset,
            profile,
        };
    }
}
_a = Run;
Run.description = 'run simulator/emulator builds from eas-cli';
Run.flags = {
    latest: core_1.Flags.boolean({
        description: 'Run the latest simulator/emulator build for specified platform',
        exclusive: ['id', 'path', 'url'],
    }),
    url: core_1.Flags.string({
        description: 'Simulator/Emulator build archive url',
        exclusive: ['latest', 'id', 'path'],
    }),
    path: core_1.Flags.string({
        description: 'Path to the simulator/emulator build archive or app',
        exclusive: ['latest', 'id', 'url'],
    }),
    id: core_1.Flags.string({
        description: 'ID of the simulator/emulator build to run',
        exclusive: ['latest, path, url'],
    }),
    platform: core_1.Flags.enum({
        char: 'p',
        options: ['android', 'ios'],
    }),
    profile: core_1.Flags.string({
        char: 'e',
        description: 'Name of the build profile used to create the build to run. When specified, only builds created with the specified build profile will be queried.',
        helpValue: 'PROFILE_NAME',
    }),
    ...pagination_1.EasPaginatedQueryFlags,
};
Run.contextDefinition = {
    ..._a.ContextOptions.LoggedIn,
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.ProjectDir,
    ..._a.ContextOptions.Vcs,
};
exports.default = Run;
async function resolvePlatformAsync(platform) {
    if (process.platform !== 'darwin') {
        return generated_1.AppPlatform.Android;
    }
    if (platform && Object.values(generated_1.AppPlatform).includes(platform.toUpperCase())) {
        return platform.toUpperCase();
    }
    const { selectedPlatform } = await (0, prompts_1.promptAsync)({
        type: 'select',
        message: 'Select platform',
        name: 'selectedPlatform',
        choices: [
            { title: 'Android', value: generated_1.AppPlatform.Android },
            { title: 'iOS', value: generated_1.AppPlatform.Ios },
        ],
    });
    return selectedPlatform;
}
function validateChosenBuild(maybeBuild, selectedPlatform) {
    if (!maybeBuild) {
        throw new Error('There are no simulator/emulator builds that can be run for this project.');
    }
    if (selectedPlatform !== maybeBuild.platform) {
        throw new Error(`The selected build is for ${platform_1.appPlatformDisplayNames[maybeBuild.platform]}, but you selected ${platform_1.appPlatformDisplayNames[selectedPlatform]}`);
    }
    if (maybeBuild.status !== generated_1.BuildStatus.Finished) {
        throw new Error('The selected build is not finished.');
    }
    if (!(0, utils_1.isRunnableOnSimulatorOrEmulator)(maybeBuild)) {
        throw new Error('Artifacts for the latest build have expired and are no longer available, or this is not a simulator/emulator build.');
    }
    return maybeBuild;
}
async function maybeGetBuildAsync(graphqlClient, flags, projectId, paginatedQueryOptions) {
    const simulator = flags.selectedPlatform === generated_1.AppPlatform.Ios ? true : undefined;
    if (flags.runArchiveFlags.id) {
        const build = await BuildQuery_1.BuildQuery.byIdAsync(graphqlClient, flags.runArchiveFlags.id);
        return validateChosenBuild(build, flags.selectedPlatform);
    }
    else if (!flags.runArchiveFlags.id &&
        !flags.runArchiveFlags.path &&
        !flags.runArchiveFlags.url &&
        !flags.runArchiveFlags.latest) {
        const build = await (0, queries_1.listAndSelectBuildOnAppAsync)(graphqlClient, {
            projectId,
            title: `Select ${platform_1.appPlatformDisplayNames[flags.selectedPlatform]} ${flags.selectedPlatform === generated_1.AppPlatform.Ios ? 'simulator' : 'emulator'} build to run for ${await (0, projectUtils_1.getDisplayNameForProjectIdAsync)(graphqlClient, projectId)} app`,
            filter: {
                platform: flags.selectedPlatform,
                status: generated_1.BuildStatus.Finished,
                buildProfile: flags.profile,
                simulator,
            },
            paginatedQueryOptions,
            selectPromptDisabledFunction: build => !(0, utils_1.isRunnableOnSimulatorOrEmulator)(build),
            selectPromptWarningMessage: `Artifacts for this build have expired and are no longer available, or this is not ${flags.selectedPlatform === generated_1.AppPlatform.Ios ? 'a simulator' : 'an emulator'} build.`,
        });
        return validateChosenBuild(build, flags.selectedPlatform);
    }
    else if (flags.runArchiveFlags.latest) {
        const latestBuild = await (0, queries_1.getLatestBuildAsync)(graphqlClient, {
            projectId,
            filter: {
                platform: flags.selectedPlatform,
                status: generated_1.BuildStatus.Finished,
                buildProfile: flags.profile,
                simulator,
            },
        });
        return validateChosenBuild(latestBuild, flags.selectedPlatform);
    }
    else {
        return null;
    }
}
function getEasBuildRunCachedAppPath(projectId, buildId, platform) {
    return path_1.default.join((0, paths_1.getEasBuildRunCacheDirectoryPath)(), `${projectId}_${buildId}.${platform === generated_1.AppPlatform.Ios ? 'app' : 'apk'}`);
}
async function getPathToSimulatorBuildAppAsync(graphqlClient, projectId, flags, queryOptions) {
    const maybeBuild = await maybeGetBuildAsync(graphqlClient, flags, projectId, queryOptions);
    if (maybeBuild) {
        const cachedAppPath = getEasBuildRunCachedAppPath(projectId, maybeBuild.id, flags.selectedPlatform);
        if (await (0, fs_extra_1.pathExists)(cachedAppPath)) {
            log_1.default.newLine();
            log_1.default.log(`Using cached app...`);
            return cachedAppPath;
        }
        if (!maybeBuild.artifacts?.applicationArchiveUrl) {
            throw new Error('Build does not have an application archive url');
        }
        return await (0, download_1.downloadAndMaybeExtractAppAsync)(maybeBuild.artifacts.applicationArchiveUrl, flags.selectedPlatform, cachedAppPath);
    }
    if (flags.runArchiveFlags.url) {
        return await (0, download_1.downloadAndMaybeExtractAppAsync)(flags.runArchiveFlags.url, flags.selectedPlatform);
    }
    if (flags.runArchiveFlags.path?.endsWith('.tar.gz')) {
        return await (0, download_1.extractAppFromLocalArchiveAsync)(flags.runArchiveFlags.path, flags.selectedPlatform);
    }
    // this should never fail, due to the validation in sanitizeFlagsAsync
    (0, assert_1.default)(flags.runArchiveFlags.path);
    return flags.runArchiveFlags.path;
}
