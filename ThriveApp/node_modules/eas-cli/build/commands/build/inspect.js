"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const local_1 = require("../../build/local");
const runBuildAndSubmit_1 = require("../../build/runBuildAndSubmit");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const platform_1 = require("../../platform");
const paths_1 = require("../../utils/paths");
var InspectStage;
(function (InspectStage) {
    InspectStage["ARCHIVE"] = "archive";
    InspectStage["PRE_BUILD"] = "pre-build";
    InspectStage["POST_BUILD"] = "post-build";
})(InspectStage || (InspectStage = {}));
const STAGE_DESCRIPTION = `Stage of the build you want to inspect.
    archive - builds the project archive that would be uploaded to EAS when building
    pre-build - prepares the project to be built with Gradle/Xcode. Does not run the native build.
    post-build - builds the native project and leaves the output directory for inspection`;
class BuildInspect extends EasCommand_1.default {
    async runAsync() {
        const { flags } = await this.parse(_a);
        const { loggedIn: { actor, graphqlClient }, getDynamicPrivateProjectConfigAsync, projectDir, analytics, vcsClient, } = await this.getContextAsync(_a, {
            nonInteractive: false,
        });
        const outputDirectory = path_1.default.resolve(process.cwd(), flags.output);
        const tmpWorkingdir = path_1.default.join((0, paths_1.getTmpDirectory)(), (0, uuid_1.v4)());
        if (flags.force && process.cwd().startsWith(outputDirectory)) {
            throw new Error(`This operation is not allowed, it would delete all files in ${outputDirectory} including the current project.`);
        }
        await this.prepareOutputDirAsync(outputDirectory, flags.force);
        if (flags.stage === InspectStage.ARCHIVE) {
            await vcsClient.ensureRepoExistsAsync();
            await vcsClient.makeShallowCopyAsync(tmpWorkingdir);
            await this.copyToOutputDirAsync(tmpWorkingdir, outputDirectory);
        }
        else {
            try {
                await (0, runBuildAndSubmit_1.runBuildAndSubmitAsync)(graphqlClient, analytics, vcsClient, projectDir, {
                    nonInteractive: false,
                    freezeCredentials: false,
                    wait: true,
                    clearCache: false,
                    json: false,
                    autoSubmit: false,
                    requestedPlatform: flags.platform,
                    profile: flags.profile,
                    localBuildOptions: {
                        localBuildMode: local_1.LocalBuildMode.LOCAL_BUILD_PLUGIN,
                        ...(flags.stage === InspectStage.PRE_BUILD ? { skipNativeBuild: true } : {}),
                        ...(flags.stage === InspectStage.POST_BUILD ? { skipCleanup: true } : {}),
                        verbose: flags.verbose,
                        workingdir: tmpWorkingdir,
                        artifactsDir: path_1.default.join(tmpWorkingdir, 'artifacts'),
                    },
                    repack: false,
                }, actor, getDynamicPrivateProjectConfigAsync);
                if (!flags.verbose) {
                    log_1.default.log(chalk_1.default.green('Build successful'));
                }
            }
            catch {
                if (!flags.verbose) {
                    log_1.default.error('Build failed');
                    log_1.default.error(`Re-run this command with ${chalk_1.default.bold('--verbose')} flag to see the logs`);
                }
            }
            finally {
                await this.copyToOutputDirAsync(path_1.default.join(tmpWorkingdir, 'build'), outputDirectory);
            }
        }
    }
    async prepareOutputDirAsync(outputDir, force) {
        if (await fs_extra_1.default.pathExists(outputDir)) {
            if (force) {
                await fs_extra_1.default.remove(outputDir);
            }
            else {
                throw new Error(`Directory ${outputDir} already exists`);
            }
        }
        await fs_extra_1.default.mkdirp(outputDir);
    }
    async copyToOutputDirAsync(src, dst) {
        const spinner = (0, ora_1.ora)().start(`Copying project directory to ${dst}`);
        try {
            if (await fs_extra_1.default.pathExists(src)) {
                await fs_extra_1.default.copy(src, dst);
            }
            await fs_extra_1.default.remove(src);
            spinner.succeed(`Project directory saved to ${dst}`);
        }
        catch (err) {
            spinner.fail();
            throw err;
        }
    }
}
_a = BuildInspect;
BuildInspect.description = 'inspect the state of the project at specific build stages, useful for troubleshooting';
BuildInspect.flags = {
    platform: core_1.Flags.enum({
        char: 'p',
        options: [platform_1.RequestedPlatform.Android, platform_1.RequestedPlatform.Ios],
        required: true,
    }),
    profile: core_1.Flags.string({
        char: 'e',
        description: 'Name of the build profile from eas.json. Defaults to "production" if defined in eas.json.',
        helpValue: 'PROFILE_NAME',
    }),
    stage: core_1.Flags.enum({
        char: 's',
        description: STAGE_DESCRIPTION,
        options: [InspectStage.ARCHIVE, InspectStage.PRE_BUILD, InspectStage.POST_BUILD],
        required: true,
    }),
    output: core_1.Flags.string({
        char: 'o',
        description: 'Output directory.',
        required: true,
        helpValue: 'OUTPUT_DIRECTORY',
    }),
    force: core_1.Flags.boolean({
        description: 'Delete OUTPUT_DIRECTORY if it already exists.',
        default: false,
    }),
    verbose: core_1.Flags.boolean({
        char: 'v',
        default: false,
    }),
};
BuildInspect.contextDefinition = {
    ..._a.ContextOptions.LoggedIn,
    ..._a.ContextOptions.DynamicProjectConfig,
    ..._a.ContextOptions.ProjectDir,
    ..._a.ContextOptions.Analytics,
    ..._a.ContextOptions.Vcs,
};
exports.default = BuildInspect;
