"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectBuildToCancelAsync = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const builds_1 = require("../../commandUtils/builds");
const flags_1 = require("../../commandUtils/flags");
const client_1 = require("../../graphql/client");
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
async function cancelBuildAsync(graphqlClient, buildId) {
    const data = await (0, client_1.withErrorHandlingAsync)(graphqlClient
        .mutation((0, graphql_tag_1.default) `
          mutation CancelBuildMutation($buildId: ID!) {
            build(buildId: $buildId) {
              cancel {
                id
                status
              }
            }
          }
        `, { buildId })
        .toPromise());
    return data.build.cancel;
}
async function selectBuildToCancelAsync(graphqlClient, projectId, projectDisplayName, filters) {
    const spinner = (0, ora_1.ora)().start('Fetching the uncompleted builds…');
    let builds;
    try {
        builds = await (0, builds_1.fetchBuildsAsync)({
            graphqlClient,
            projectId,
            filters: {
                ...filters,
                statuses: [generated_1.BuildStatus.New, generated_1.BuildStatus.InQueue, generated_1.BuildStatus.InProgress],
            },
        });
        spinner.stop();
    }
    catch (error) {
        spinner.fail(`Something went wrong and we couldn't fetch the builds for the project ${projectDisplayName}.`);
        throw error;
    }
    if (builds.length === 0) {
        log_1.default.warn(`We couldn't find any uncompleted builds for the project ${projectDisplayName}.`);
        return null;
    }
    else {
        const buildId = await (0, prompts_1.selectAsync)('Which build do you want to cancel?', builds.map(build => ({
            title: (0, builds_1.formatBuild)(build),
            value: build.id,
        })));
        return (await (0, prompts_1.confirmAsync)({
            message: 'Are you sure you want to cancel it?',
        }))
            ? buildId
            : null;
    }
}
exports.selectBuildToCancelAsync = selectBuildToCancelAsync;
class BuildCancel extends EasCommand_1.default {
    async runAsync() {
        const { args: { BUILD_ID: buildIdFromArg }, flags: { 'non-interactive': nonInteractive, platform, profile }, } = await this.parse(_a);
        if (buildIdFromArg && (platform || profile)) {
            throw new Error('Build ID cannot be used together with platform and profile flags. They are used to filter the list of builds when not providing the build ID');
        }
        const { privateProjectConfig: { projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(_a, {
            nonInteractive,
        });
        const displayName = await (0, projectUtils_1.getDisplayNameForProjectIdAsync)(graphqlClient, projectId);
        if (buildIdFromArg) {
            await (0, builds_1.ensureBuildExistsAsync)(graphqlClient, buildIdFromArg);
        }
        let buildId = buildIdFromArg;
        if (!buildId) {
            if (nonInteractive) {
                throw new Error('Build ID must be provided in non-interactive mode');
            }
            buildId = await selectBuildToCancelAsync(graphqlClient, projectId, displayName, {
                platform,
                profile,
            });
            if (!buildId) {
                return;
            }
        }
        const spinner = (0, ora_1.ora)().start('Canceling the build…');
        try {
            const { status } = await cancelBuildAsync(graphqlClient, buildId);
            if ([generated_1.BuildStatus.Canceled, generated_1.BuildStatus.PendingCancel].includes(status)) {
                spinner.succeed('Build canceled');
            }
            else {
                spinner.text = 'Build is already completed';
                spinner.stopAndPersist();
            }
        }
        catch (error) {
            spinner.fail(`Something went wrong and we couldn't cancel your build ${buildId}`);
            throw error;
        }
    }
}
_a = BuildCancel;
BuildCancel.description = 'cancel a build';
BuildCancel.args = [{ name: 'BUILD_ID' }];
BuildCancel.flags = {
    ...flags_1.EASNonInteractiveFlag,
    platform: core_1.Flags.enum({
        char: 'p',
        description: 'Filter builds by the platform if build ID is not provided',
        options: Object.values(platform_1.RequestedPlatform),
    }),
    profile: core_1.Flags.string({
        char: 'e',
        description: 'Filter builds by build profile if build ID is not provided',
        helpValue: 'PROFILE_NAME',
    }),
};
BuildCancel.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
    ..._a.ContextOptions.Vcs,
};
exports.default = BuildCancel;
