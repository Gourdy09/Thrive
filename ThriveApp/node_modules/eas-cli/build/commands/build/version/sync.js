"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const eas_json_1 = require("@expo/eas-json");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const version_1 = require("../../../build/android/version");
const evaluateConfigWithEnvVarsAsync_1 = require("../../../build/evaluateConfigWithEnvVarsAsync");
const version_2 = require("../../../build/ios/version");
const EasCommand_1 = tslib_1.__importDefault(require("../../../commandUtils/EasCommand"));
const AppVersionQuery_1 = require("../../../graphql/queries/AppVersionQuery");
const AppPlatform_1 = require("../../../graphql/types/AppPlatform");
const log_1 = tslib_1.__importDefault(require("../../../log"));
const platform_1 = require("../../../platform");
const gradleUtils_1 = require("../../../project/android/gradleUtils");
const versions_1 = require("../../../project/android/versions");
const applicationIdentifier_1 = require("../../../project/applicationIdentifier");
const scheme_1 = require("../../../project/ios/scheme");
const target_1 = require("../../../project/ios/target");
const versions_2 = require("../../../project/ios/versions");
const remoteVersionSource_1 = require("../../../project/remoteVersionSource");
const workflow_1 = require("../../../project/workflow");
const profiles_1 = require("../../../utils/profiles");
class BuildVersionSyncView extends EasCommand_1.default {
    async runAsync() {
        const { flags } = await this.parse(_a);
        const { loggedIn: { graphqlClient }, getDynamicPrivateProjectConfigAsync, projectDir, vcsClient, } = await this.getContextAsync(_a, {
            nonInteractive: true,
        });
        const requestedPlatform = await (0, platform_1.selectRequestedPlatformAsync)(flags.platform);
        const easJsonAccessor = eas_json_1.EasJsonAccessor.fromProjectPath(projectDir);
        await (0, remoteVersionSource_1.ensureVersionSourceIsRemoteAsync)(easJsonAccessor, { nonInteractive: false });
        const platforms = (0, platform_1.toPlatforms)(requestedPlatform);
        const buildProfiles = await (0, profiles_1.getProfilesAsync)({
            type: 'build',
            easJsonAccessor,
            platforms,
            profileName: flags.profile ?? undefined,
            projectDir,
        });
        for (const profileInfo of buildProfiles) {
            const { exp, projectId, env } = await (0, evaluateConfigWithEnvVarsAsync_1.evaluateConfigWithEnvVarsAsync)({
                buildProfile: profileInfo.profile,
                buildProfileName: profileInfo.profileName,
                graphqlClient,
                getProjectConfig: getDynamicPrivateProjectConfigAsync,
                opts: { env: profileInfo.profile.env },
            });
            (0, remoteVersionSource_1.validateAppConfigForRemoteVersionSource)(exp, profileInfo.platform);
            const platformDisplayName = platform_1.appPlatformDisplayNames[(0, AppPlatform_1.toAppPlatform)(profileInfo.platform)];
            const applicationIdentifier = await (0, applicationIdentifier_1.getApplicationIdentifierAsync)({
                graphqlClient,
                projectDir,
                projectId,
                exp,
                buildProfile: profileInfo.profile,
                platform: profileInfo.platform,
                vcsClient,
                nonInteractive: false,
                env,
            });
            const remoteVersions = await AppVersionQuery_1.AppVersionQuery.latestVersionAsync(graphqlClient, projectId, (0, AppPlatform_1.toAppPlatform)(profileInfo.platform), applicationIdentifier);
            const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, profileInfo.platform, vcsClient);
            if (!remoteVersions?.buildVersion) {
                log_1.default.warn(`Skipping versions sync for ${platformDisplayName}. There are no versions configured on Expo servers, use "eas build:version:set" or run a build to initialize it.`);
                continue;
            }
            if (workflow === eas_build_job_1.Workflow.MANAGED) {
                log_1.default.warn(`The remote value for the ${platformDisplayName} ${(0, remoteVersionSource_1.getBuildVersionName)(profileInfo.platform)} is ${chalk_1.default.bold(remoteVersions?.buildVersion)}, but it was not synced to the local project. This command has no effect on projects using managed workflow.`);
                continue;
            }
            if (profileInfo.platform === eas_build_job_1.Platform.ANDROID) {
                await this.syncAndroidAsync({
                    projectDir,
                    exp,
                    profile: profileInfo.profile,
                    workflow,
                    buildVersion: remoteVersions.buildVersion,
                    vcsClient,
                });
            }
            else {
                await this.syncIosAsync({
                    projectDir,
                    exp,
                    profile: profileInfo.profile,
                    workflow,
                    buildVersion: remoteVersions.buildVersion,
                    vcsClient,
                });
            }
            log_1.default.withTick(`Successfully updated the ${platformDisplayName} ${(0, remoteVersionSource_1.getBuildVersionName)(profileInfo.platform)} in native code to ${chalk_1.default.bold(remoteVersions?.buildVersion)}.`);
        }
    }
    async syncIosAsync({ workflow, projectDir, exp, profile, buildVersion, vcsClient, }) {
        const xcodeBuildContext = await (0, scheme_1.resolveXcodeBuildContextAsync)({ exp, projectDir, nonInteractive: false, vcsClient }, profile);
        const targets = await (0, target_1.resolveTargetsAsync)({
            projectDir,
            exp,
            xcodeBuildContext,
            env: profile.env,
            vcsClient,
        });
        if (!(0, versions_2.isValidBuildNumber)(buildVersion)) {
            throw new Error(`Invalid buildNumber (${buildVersion}), ${versions_2.BUILD_NUMBER_REQUIREMENTS}.`);
        }
        if (workflow === eas_build_job_1.Workflow.GENERIC) {
            await (0, version_2.updateNativeVersionsAsync)({
                projectDir,
                buildNumber: buildVersion,
                targets,
            });
        }
    }
    async syncAndroidAsync({ projectDir, workflow, buildVersion, }) {
        if (!(0, versions_1.isValidVersionCode)(buildVersion)) {
            throw new Error(`Invalid versionCode (${buildVersion}), ${versions_1.VERSION_CODE_REQUIREMENTS}.`);
        }
        if (workflow === eas_build_job_1.Workflow.GENERIC) {
            const buildGradle = await (0, gradleUtils_1.getAppBuildGradleAsync)(projectDir);
            const isMultiFlavor = buildGradle.android?.productFlavors ?? buildGradle.android?.flavorDimensions;
            if (isMultiFlavor) {
                throw new Error("Versions in native code can't be automatically synced in multi-flavor Android projects. If you are using EAS Build with app version source set to remote, the correct values will be injected at the build time.");
            }
            await (0, version_1.updateNativeVersionsAsync)({ projectDir, versionCode: Number(buildVersion) });
        }
    }
}
_a = BuildVersionSyncView;
BuildVersionSyncView.description = 'update a version in native code with a value stored on EAS servers';
BuildVersionSyncView.flags = {
    platform: core_1.Flags.enum({
        char: 'p',
        options: ['android', 'ios', 'all'],
    }),
    profile: core_1.Flags.string({
        char: 'e',
        description: 'Name of the build profile from eas.json. Defaults to "production" if defined in eas.json.',
        helpValue: 'PROFILE_NAME',
    }),
};
BuildVersionSyncView.contextDefinition = {
    ..._a.ContextOptions.LoggedIn,
    ..._a.ContextOptions.DynamicProjectConfig,
    ..._a.ContextOptions.ProjectDir,
    ..._a.ContextOptions.Vcs,
};
exports.default = BuildVersionSyncView;
