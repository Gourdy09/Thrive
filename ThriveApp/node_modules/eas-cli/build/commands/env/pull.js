"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const fs = tslib_1.__importStar(require("fs-extra"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const EnvironmentVariablesQuery_1 = require("../../graphql/queries/EnvironmentVariablesQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const prompts_1 = require("../../prompts");
const prompts_2 = require("../../utils/prompts");
class EnvironmentVariablePull extends EasCommand_1.default {
    async runAsync() {
        let { flags: { environment, path: targetPath, 'non-interactive': nonInteractive }, } = await this.parse(_a);
        if (!environment) {
            environment = await (0, prompts_2.promptVariableEnvironmentAsync)(nonInteractive);
        }
        const { privateProjectConfig: { projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(_a, {
            nonInteractive,
        });
        targetPath = targetPath ?? '.env.local';
        const environmentVariables = await EnvironmentVariablesQuery_1.EnvironmentVariablesQuery.byAppIdWithSensitiveAsync(graphqlClient, {
            appId: projectId,
            environment,
        });
        if (!nonInteractive && (await fs.exists(targetPath))) {
            const result = await (0, prompts_1.confirmAsync)({
                message: `File ${targetPath} already exists. Do you want to overwrite it?`,
            });
            if (!result) {
                log_1.default.log('Aborting...');
                throw new Error(`File ${targetPath} already exists.`);
            }
        }
        const filePrefix = `# Environment: ${environment}\n\n`;
        const envFileContent = environmentVariables
            .map((variable) => {
            if (variable.value === null) {
                return `# ${variable.name}=***** (secret variables are not available for reading)`;
            }
            return `${variable.name}=${variable.value}`;
        })
            .join('\n');
        await fs.writeFile(targetPath, filePrefix + envFileContent);
        const secretEnvVariables = environmentVariables.filter((variable) => variable.value === null);
        if (secretEnvVariables.length > 0) {
            log_1.default.warn(`The eas env:pull command tried to pull environment variables with "secret" visibility. The variables with "secret" visibility are not available for reading, therefore thet were marked as "*****" in the generated .env file. Provide values for these manually in ${targetPath} if needed. Skipped variables: ${secretEnvVariables
                .map(v => v.name)
                .join('\n')}`);
            log_1.default.warn();
        }
        log_1.default.log(`Pulled environment variables from ${environment.toLowerCase()} environment to ${targetPath}.`);
    }
}
_a = EnvironmentVariablePull;
EnvironmentVariablePull.description = 'pull env file';
EnvironmentVariablePull.hidden = true;
EnvironmentVariablePull.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
EnvironmentVariablePull.flags = {
    ...flags_1.EASEnvironmentFlag,
    ...flags_1.EASNonInteractiveFlag,
    path: core_1.Flags.string({
        description: 'Path to the result `.env` file',
        default: '.env.local',
    }),
};
exports.default = EnvironmentVariablePull;
