"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const dotenv_1 = tslib_1.__importDefault(require("dotenv"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const generated_1 = require("../../graphql/generated");
const EnvironmentVariableMutation_1 = require("../../graphql/mutations/EnvironmentVariableMutation");
const EnvironmentVariablesQuery_1 = require("../../graphql/queries/EnvironmentVariablesQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const prompts_1 = require("../../prompts");
class EnvironmentVariablePush extends EasCommand_1.default {
    async runAsync() {
        const { flags } = await this.parse(_a);
        const { environment, path: envPath } = this.validateFlags(flags);
        const { privateProjectConfig: { projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(_a, {
            nonInteractive: false,
        });
        const updateVariables = await this.parseEnvFileAsync(envPath, environment);
        const variableNames = Object.keys(updateVariables);
        const existingVariables = await EnvironmentVariablesQuery_1.EnvironmentVariablesQuery.byAppIdAsync(graphqlClient, {
            appId: projectId,
            environment,
            filterNames: variableNames,
        });
        const existingDifferentVariables = [];
        // Remove variables that are the same as the ones in the environment
        existingVariables.forEach(variable => {
            const existingVariableUpdate = updateVariables[variable.name];
            if (existingVariableUpdate && existingVariableUpdate.value !== variable.value) {
                existingDifferentVariables.push(variable);
            }
            else {
                delete updateVariables[variable.name];
            }
        });
        const existingDifferentSharedVariables = existingDifferentVariables.filter(variable => variable.scope === generated_1.EnvironmentVariableScope.Shared);
        if (existingDifferentSharedVariables.length > 0) {
            const existingDifferentSharedVariablesNames = existingDifferentSharedVariables.map(variable => variable.name);
            log_1.default.error('Shared variables cannot be overwritten by eas env:push command.');
            log_1.default.error('Remove them from the env file or unlink them from the project to continue:');
            existingDifferentSharedVariablesNames.forEach(name => {
                log_1.default.error(`- ${name}`);
            });
            throw new Error('Shared variables cannot be overwritten by eas env:push command');
        }
        if (existingDifferentVariables.length > 0) {
            log_1.default.warn('Some variables already exist in the environment.');
            const variableNames = existingDifferentVariables.map(variable => variable.name);
            const confirmationMessage = variableNames.length > 1
                ? `The ${variableNames.join(', ')} environment variables already exist in ${environment} environment. Do you want to override them all?`
                : `The ${variableNames[0]} environment variable already exists in ${environment} environment. Do you want to override it?`;
            const confirm = await (0, prompts_1.confirmAsync)({
                message: confirmationMessage,
            });
            let variablesToOverwrite = [];
            if (!confirm && existingDifferentVariables.length === 1) {
                throw new Error('No new variables to push.');
            }
            if (confirm) {
                variablesToOverwrite = existingDifferentVariables.map(variable => variable.name);
            }
            else {
                const promptResult = await (0, prompts_1.promptAsync)({
                    type: 'multiselect',
                    name: 'variablesToOverwrite',
                    message: 'Select variables to overwrite:',
                    // @ts-expect-error property missing from `@types/prompts`
                    optionsPerPage: 20,
                    choices: existingDifferentVariables.map(variable => ({
                        title: `${variable.name}: ${updateVariables[variable.name].value} (was ${variable.value ?? '(secret)'})`,
                        value: variable.name,
                    })),
                });
                variablesToOverwrite = promptResult.variablesToOverwrite;
            }
            for (const existingVariable of existingVariables) {
                const name = existingVariable.name;
                if (variablesToOverwrite.includes(name)) {
                    updateVariables[name]['overwrite'] = true;
                }
                else {
                    delete updateVariables[name];
                }
            }
        }
        // Check if any of the sensitive variables already exist in the environment. Prompt the user to overwrite them.
        const existingSensitiveVariables = existingVariables.filter(variable => variable.value === null);
        if (existingSensitiveVariables.length > 0) {
            const existingSensitiveVariablesNames = existingSensitiveVariables.map(variable => `- ${variable.name}`);
            const confirm = await (0, prompts_1.confirmAsync)({
                message: `You are about to overwrite sensitive variables.\n${existingSensitiveVariablesNames.join('\n')}\n Do you want to continue?`,
            });
            if (!confirm) {
                throw new Error('Aborting...');
            }
        }
        const variablesToPush = Object.values(updateVariables);
        if (variablesToPush.length === 0) {
            log_1.default.log('No new variables to push.');
            return;
        }
        await EnvironmentVariableMutation_1.EnvironmentVariableMutation.createBulkEnvironmentVariablesForAppAsync(graphqlClient, variablesToPush, projectId);
        log_1.default.log(`Uploaded env file to ${environment} environment.`);
    }
    async parseEnvFileAsync(envPath, environment) {
        if (!(await fs_extra_1.default.exists(envPath))) {
            throw new Error(`File ${envPath} does not exist.`);
        }
        const pushInput = {};
        const variables = dotenv_1.default.parse(await fs_extra_1.default.readFile(envPath, 'utf8'));
        for (const [name, value] of Object.entries(variables)) {
            pushInput[name] = {
                name,
                value,
                environment,
                visibility: name.startsWith('EXPO_SENSITIVE')
                    ? generated_1.EnvironmentVariableVisibility.Sensitive
                    : generated_1.EnvironmentVariableVisibility.Public,
            };
        }
        return pushInput;
    }
    validateFlags(flags) {
        if (!flags.environment) {
            throw new Error('Please provide an environment to push the env file to.');
        }
        return { ...flags, environment: flags.environment };
    }
}
_a = EnvironmentVariablePush;
EnvironmentVariablePush.description = 'push env file';
EnvironmentVariablePush.hidden = true;
EnvironmentVariablePush.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
EnvironmentVariablePush.flags = {
    ...flags_1.EASEnvironmentFlag,
    path: core_1.Flags.string({
        description: 'Path to the input `.env` file',
        default: '.env.local',
    }),
};
exports.default = EnvironmentVariablePush;
