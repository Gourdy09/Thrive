"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const spawn_async_1 = tslib_1.__importDefault(require("@expo/spawn-async"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const EnvironmentVariablesQuery_1 = require("../../graphql/queries/EnvironmentVariablesQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const prompts_1 = require("../../utils/prompts");
class EnvExec extends EasCommand_1.default {
    async runAsync() {
        const { flags, args: { BASH_COMMAND: command }, } = await this.parse(_a);
        const parsedFlags = this.sanitizeFlags(flags);
        const { privateProjectConfig: { projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(_a, {
            nonInteractive: parsedFlags.nonInteractive,
        });
        const environment = parsedFlags.environment ?? (await (0, prompts_1.promptVariableEnvironmentAsync)(parsedFlags.nonInteractive));
        const environmentVariables = await this.loadEnvironmentVariablesAsync({
            graphqlClient,
            projectId,
            environment,
        });
        await this.runCommandWithEnvVarsAsync({ command, environmentVariables });
    }
    sanitizeFlags(rawFlags) {
        const environment = rawFlags.environment;
        if (rawFlags['non-interactive']) {
            if (!environment) {
                throw new Error('You must specify an environment when running in non-interactive mode. Use the --environment flag.');
            }
            return {
                nonInteractive: true,
                environment,
            };
        }
        return {
            nonInteractive: false,
            environment: rawFlags.environment,
        };
    }
    async runCommandWithEnvVarsAsync({ command, environmentVariables, }) {
        log_1.default.log(`Running command: ${chalk_1.default.bold(command)}`);
        const spawnPromise = (0, spawn_async_1.default)('bash', ['-c', command], {
            stdio: ['inherit', 'pipe', 'pipe'],
            env: {
                ...process.env,
                ...environmentVariables,
            },
        });
        const { child: { stdout, stderr }, } = spawnPromise;
        if (!stdout || !stderr) {
            throw new Error(`Failed to spawn ${command}`);
        }
        stdout.on('data', data => {
            for (const line of data.toString().trim().split('\n')) {
                log_1.default.log(`${chalk_1.default.gray('[stdout]')} ${line}`);
            }
        });
        stderr.on('data', data => {
            for (const line of data.toString().trim().split('\n')) {
                log_1.default.warn(`${chalk_1.default.gray('[stderr]')} ${line}`);
            }
        });
        try {
            await spawnPromise;
        }
        catch (error) {
            log_1.default.error(`❌ ${chalk_1.default.bold(command)} failed`);
            throw error;
        }
    }
    async loadEnvironmentVariablesAsync({ graphqlClient, projectId, environment, }) {
        const environmentVariablesQueryResult = await EnvironmentVariablesQuery_1.EnvironmentVariablesQuery.byAppIdWithSensitiveAsync(graphqlClient, {
            appId: projectId,
            environment,
        });
        const secretEnvironmentVariables = environmentVariablesQueryResult.filter(({ value }) => !value);
        if (secretEnvironmentVariables.length > 0) {
            log_1.default.warn(`The following environment variables are secret and cannot be downloaded locally:`);
            for (const { name } of secretEnvironmentVariables) {
                log_1.default.warn(`- ${name}`);
            }
            log_1.default.warn('Proceeding with the rest of the environment variables.');
            log_1.default.newLine();
        }
        const nonSecretEnvironmentVariables = environmentVariablesQueryResult.filter(({ value }) => !!value);
        if (nonSecretEnvironmentVariables.length === 0) {
            throw new Error('No readable environment variables found for the selected environment.');
        }
        log_1.default.log(`Loaded environment variables for the selected environment "${environment.toLowerCase()}":`);
        for (const { name } of nonSecretEnvironmentVariables) {
            log_1.default.log(`- ${name}`);
        }
        log_1.default.newLine();
        const environmentVariables = {};
        for (const { name, value } of nonSecretEnvironmentVariables) {
            if (value) {
                environmentVariables[name] = value;
            }
        }
        return environmentVariables;
    }
}
_a = EnvExec;
EnvExec.description = 'execute a bash command with environment variables from the selected environment';
EnvExec.hidden = true;
EnvExec.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
EnvExec.flags = {
    ...flags_1.EASEnvironmentFlag,
    ...flags_1.EASNonInteractiveFlag,
};
EnvExec.args = [
    {
        name: 'BASH_COMMAND',
        required: true,
        description: 'bash command to execute with the environment variables from the environment',
    },
];
exports.default = EnvExec;
