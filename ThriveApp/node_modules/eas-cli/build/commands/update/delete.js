"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const client_1 = require("../../graphql/client");
const log_1 = tslib_1.__importDefault(require("../../log"));
const prompts_1 = require("../../prompts");
const json_1 = require("../../utils/json");
async function deleteUpdateGroupAsync(graphqlClient, { group, }) {
    return await (0, client_1.withErrorHandlingAsync)(graphqlClient
        .mutation((0, graphql_tag_1.default) `
          mutation DeleteUpdateGroup($group: ID!) {
            update {
              deleteUpdateGroup(group: $group) {
                group
              }
            }
          }
        `, { group })
        .toPromise());
}
class UpdateDelete extends EasCommand_1.default {
    async runAsync() {
        const { args: { groupId: group }, flags: { json: jsonFlag, 'non-interactive': nonInteractive }, } = await this.parse(_a);
        const { loggedIn: { graphqlClient }, } = await this.getContextAsync(_a, { nonInteractive });
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        if (!nonInteractive) {
            const shouldAbort = await (0, prompts_1.confirmAsync)({
                message: `ðŸš¨${chalk_1.default.red('CAUTION')}ðŸš¨\n\n` +
                    `${chalk_1.default.yellow(`This will delete all of the updates in group "${group}".`)} ${chalk_1.default.red('This is a permanent operation.')}\n\n` +
                    `If you want to revert to a previous publish, you should use 'update --republish' targeted at the last working update group instead.\n\n` +
                    `An update group should only be deleted in an emergency like an accidental publish of a secret. In this case user 'update --republish' to revert to the last working update group first and then proceed with the deletion. Deleting an update group when it is the latest publish can lead to inconsistent caching behavior by clients.\n\n` +
                    `Would you like to abort?`,
            });
            if (shouldAbort) {
                log_1.default.log('Aborted.');
                return;
            }
        }
        await deleteUpdateGroupAsync(graphqlClient, { group });
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)({ group });
        }
        else {
            log_1.default.withTick(`Deleted update group ${group}`);
        }
    }
}
_a = UpdateDelete;
UpdateDelete.description = 'delete all the updates in an update group';
UpdateDelete.args = [
    {
        name: 'groupId',
        required: true,
        description: 'The ID of an update group to delete.',
    },
];
UpdateDelete.flags = {
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
UpdateDelete.contextDefinition = {
    ..._a.ContextOptions.LoggedIn,
};
exports.default = UpdateDelete;
