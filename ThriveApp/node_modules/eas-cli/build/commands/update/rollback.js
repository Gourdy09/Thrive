"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const republish_1 = tslib_1.__importDefault(require("./republish"));
const roll_back_to_embedded_1 = tslib_1.__importDefault(require("./roll-back-to-embedded"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const prompts_1 = require("../../prompts");
class UpdateRollback extends EasCommand_1.default {
    async runAsync() {
        const { flags } = await this.parse(UpdateRollback);
        const { choice } = await (0, prompts_1.promptAsync)({
            type: 'select',
            message: 'Which type of update would you like to roll back to?',
            name: 'choice',
            choices: [
                { title: 'Published Update', value: 'published' },
                { title: 'Embedded Update', value: 'embedded' },
            ],
        });
        const privateKeyPathArg = flags['private-key-path']
            ? ['--private-key-path', flags['private-key-path']]
            : [];
        if (choice === 'published') {
            await republish_1.default.run(privateKeyPathArg);
        }
        else {
            await roll_back_to_embedded_1.default.run(privateKeyPathArg);
        }
    }
}
UpdateRollback.description = 'roll back to an embedded update or an existing update';
UpdateRollback.flags = {
    'private-key-path': core_1.Flags.string({
        description: `File containing the PEM-encoded private key corresponding to the certificate in expo-updates' configuration. Defaults to a file named "private-key.pem" in the certificate's directory. Only relevant if you are using code signing: https://docs.expo.dev/eas-update/code-signing/`,
        required: false,
    }),
};
exports.default = UpdateRollback;
