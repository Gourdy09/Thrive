"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.canAccessRepositoryUsingSshAsync = exports.runGitPushAsync = exports.runGitCloneAsync = void 0;
const tslib_1 = require("tslib");
const spawn_async_1 = tslib_1.__importDefault(require("@expo/spawn-async"));
const runCommand_1 = require("./runCommand");
const log_1 = tslib_1.__importDefault(require("../log"));
const prompts_1 = require("../prompts");
async function runGitCloneAsync({ targetProjectDir, githubRepositoryName, githubUsername, cloneMethod, }) {
    const url = cloneMethod === 'ssh'
        ? `git@github.com:${githubUsername}/${githubRepositoryName}.git`
        : `https://github.com/${githubUsername}/${githubRepositoryName}.git`;
    try {
        await (0, runCommand_1.runCommandAsync)({
            command: 'git',
            args: ['clone', url, targetProjectDir],
            shouldPrintStderrLineAsStdout: line => {
                return line.includes('Cloning into');
            },
            showSpinner: false,
        });
        return { targetProjectDir };
    }
    catch (error) {
        if (error.stderr.includes('already exists')) {
            log_1.default.warn(`Directory ${targetProjectDir} already exists.`);
            const shouldContinue = await (0, prompts_1.confirmAsync)({
                message: 'Do you want to clone your project to some other destination?',
            });
            if (!shouldContinue) {
                throw new Error('Directory already exists. Aborting...');
            }
            const { newTargetProjectDir } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'newTargetProjectDir',
                message: 'New target directory path:',
                validate: (input) => input !== '',
            });
            return await runGitCloneAsync({
                githubRepositoryName,
                githubUsername,
                targetProjectDir: newTargetProjectDir,
                cloneMethod,
            });
        }
        else if (error.stderr.includes('Permission denied')) {
            log_1.default.warn(`It seems like you do not have permission to clone the repository using ${cloneMethod}.`);
            const newMethod = cloneMethod === 'ssh' ? 'https' : 'ssh';
            const shouldContinue = await (0, prompts_1.confirmAsync)({
                message: `Do you want to clone the repository using ${newMethod} instead?`,
            });
            if (!shouldContinue) {
                throw new Error('Permission denied. Aborting...');
            }
            return await runGitCloneAsync({
                githubRepositoryName,
                githubUsername,
                targetProjectDir,
                cloneMethod: newMethod,
            });
        }
        else {
            throw error;
        }
    }
}
exports.runGitCloneAsync = runGitCloneAsync;
async function runGitPushAsync({ targetProjectDir, }) {
    await (0, runCommand_1.runCommandAsync)({
        command: 'git',
        args: ['push'],
        cwd: targetProjectDir,
    });
}
exports.runGitPushAsync = runGitPushAsync;
async function canAccessRepositoryUsingSshAsync({ githubUsername, githubRepositoryName, }) {
    try {
        await (0, spawn_async_1.default)('git', [
            'ls-remote',
            `git@github.com:${githubUsername}/${githubRepositoryName}.git`,
        ]);
        return true;
    }
    catch {
        return false;
    }
}
exports.canAccessRepositoryUsingSshAsync = canAccessRepositoryUsingSshAsync;
