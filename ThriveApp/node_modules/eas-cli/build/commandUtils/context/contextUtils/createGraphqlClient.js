"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGraphqlClient = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@urql/core");
const exchange_retry_1 = require("@urql/exchange-retry");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const api_1 = require("../../../api");
const fetch_1 = require("../../../fetch");
function createGraphqlClient(authInfo) {
    return (0, core_1.createClient)({
        url: (0, api_1.getExpoApiBaseUrl)() + '/graphql',
        exchanges: [
            core_1.cacheExchange,
            (0, exchange_retry_1.retryExchange)({
                maxDelayMs: 4000,
                retryIf: (err, operation) => {
                    return !!(err &&
                        !operation.context.noRetry &&
                        (err.networkError ?? err.graphQLErrors.some(e => e?.extensions?.isTransient)));
                },
            }),
            core_1.fetchExchange,
        ],
        // @ts-expect-error Type 'typeof fetch' is not assignable to type '(input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>'.
        fetch: node_fetch_1.default,
        fetchOptions: () => {
            const headers = {};
            if (authInfo.accessToken) {
                headers.authorization = `Bearer ${authInfo.accessToken}`;
            }
            else if (authInfo.sessionSecret) {
                headers['expo-session'] = authInfo.sessionSecret;
            }
            return {
                ...(fetch_1.httpsProxyAgent ? { agent: fetch_1.httpsProxyAgent } : {}),
                headers,
            };
        },
    });
}
exports.createGraphqlClient = createGraphqlClient;
