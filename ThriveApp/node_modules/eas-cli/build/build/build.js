"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForBuildEndAsync = exports.handleBuildRequestError = exports.prepareBuildRequestForPlatformAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_progress_1 = tslib_1.__importDefault(require("cli-progress"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const errors_1 = require("./errors");
const graphql_1 = require("./graphql");
const local_1 = require("./local");
const metadata_1 = require("./metadata");
const printBuildInfo_1 = require("./utils/printBuildInfo");
const repository_1 = require("./utils/repository");
const AnalyticsManager_1 = require("../analytics/AnalyticsManager");
const common_1 = require("../analytics/common");
const api_1 = require("../api");
const generated_1 = require("../graphql/generated");
const BuildMutation_1 = require("../graphql/mutations/BuildMutation");
const BuildQuery_1 = require("../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importStar(require("../log"));
const ora_1 = require("../ora");
const platform_1 = require("../platform");
const maybeUploadFingerprintAsync_1 = require("../project/maybeUploadFingerprintAsync");
const resolveRuntimeVersionAsync_1 = require("../project/resolveRuntimeVersionAsync");
const uploads_1 = require("../uploads");
const files_1 = require("../utils/files");
const json_1 = require("../utils/json");
const progress_1 = require("../utils/progress");
const promise_1 = require("../utils/promise");
function resolveBuildParamsInput(ctx, metadata) {
    return {
        resourceClass: ctx.resourceClass,
        sdkVersion: metadata.sdkVersion,
        reactNativeVersion: metadata.reactNativeVersion,
    };
}
async function prepareBuildRequestForPlatformAsync(builder) {
    const { ctx } = builder;
    const credentialsResult = await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => await builder.ensureCredentialsAsync(ctx), {
        attemptEvent: AnalyticsManager_1.BuildEvent.GATHER_CREDENTIALS_ATTEMPT,
        successEvent: AnalyticsManager_1.BuildEvent.GATHER_CREDENTIALS_SUCCESS,
        failureEvent: AnalyticsManager_1.BuildEvent.GATHER_CREDENTIALS_FAIL,
        properties: ctx.analyticsEventProperties,
    });
    await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => {
        await builder.syncProjectConfigurationAsync(ctx);
    }, {
        attemptEvent: AnalyticsManager_1.BuildEvent.CONFIGURE_PROJECT_ATTEMPT,
        successEvent: AnalyticsManager_1.BuildEvent.CONFIGURE_PROJECT_SUCCESS,
        failureEvent: AnalyticsManager_1.BuildEvent.CONFIGURE_PROJECT_FAIL,
        properties: ctx.analyticsEventProperties,
    });
    if (await ctx.vcsClient.isCommitRequiredAsync()) {
        log_1.default.addNewLineIfNone();
        const platformToRequestedPlatform = {
            [eas_build_job_1.Platform.ANDROID]: platform_1.RequestedPlatform.Android,
            [eas_build_job_1.Platform.IOS]: platform_1.RequestedPlatform.Ios,
        };
        await (0, repository_1.reviewAndCommitChangesAsync)(ctx.vcsClient, `[EAS Build] Run EAS Build for ${platform_1.requestedPlatformDisplayNames[platformToRequestedPlatform[ctx.platform]]}`, { nonInteractive: ctx.nonInteractive });
    }
    let projectArchive;
    if (ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.LOCAL_BUILD_PLUGIN) {
        const projectPath = (await (0, repository_1.makeProjectTarballAsync)(ctx.vcsClient)).path;
        projectArchive = {
            type: eas_build_job_1.ArchiveSourceType.PATH,
            path: projectPath,
        };
    }
    else if (ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.INTERNAL) {
        projectArchive = {
            type: eas_build_job_1.ArchiveSourceType.PATH,
            path: process.cwd(),
        };
    }
    else if (!ctx.localBuildOptions.localBuildMode) {
        projectArchive = {
            type: eas_build_job_1.ArchiveSourceType.GCS,
            ...(await uploadProjectAsync(ctx)),
        };
    }
    (0, assert_1.default)(projectArchive);
    const runtimeMetadata = await createAndMaybeUploadFingerprintAsync(ctx);
    const metadata = await (0, metadata_1.collectMetadataAsync)(ctx, runtimeMetadata);
    const buildParams = resolveBuildParamsInput(ctx, metadata);
    const job = await builder.prepareJobAsync(ctx, {
        projectArchive,
        credentials: credentialsResult?.credentials,
    });
    return async () => {
        if (ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.LOCAL_BUILD_PLUGIN) {
            await (0, local_1.runLocalBuildAsync)(job, metadata, ctx.localBuildOptions, ctx.env);
            return undefined;
        }
        else if (ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.INTERNAL) {
            await BuildMutation_1.BuildMutation.updateBuildMetadataAsync(ctx.graphqlClient, {
                buildId: (0, nullthrows_1.default)(process.env.EAS_BUILD_ID),
                metadata: (0, graphql_1.transformMetadata)(metadata),
            });
            (0, json_1.printJsonOnlyOutput)({ job, metadata });
            return undefined;
        }
        else if (!ctx.localBuildOptions.localBuildMode) {
            try {
                return await sendBuildRequestAsync(builder, job, metadata, buildParams);
            }
            catch (error) {
                handleBuildRequestError(error, job.platform);
            }
        }
        else {
            throw new Error('Unknown localBuildMode.');
        }
    };
}
exports.prepareBuildRequestForPlatformAsync = prepareBuildRequestForPlatformAsync;
const SERVER_SIDE_DEFINED_ERRORS = {
    TURTLE_DEPRECATED_JOB_FORMAT: errors_1.TurtleDeprecatedJobFormatError,
    EAS_BUILD_FREE_TIER_DISABLED: errors_1.EasBuildFreeTierDisabledError,
    EAS_BUILD_FREE_TIER_DISABLED_IOS: errors_1.EasBuildFreeTierDisabledIOSError,
    EAS_BUILD_FREE_TIER_DISABLED_ANDROID: errors_1.EasBuildFreeTierDisabledAndroidError,
    EAS_BUILD_FREE_TIER_LIMIT_EXCEEDED: errors_1.EasBuildFreeTierLimitExceededError,
    EAS_BUILD_FREE_TIER_IOS_LIMIT_EXCEEDED: errors_1.EasBuildFreeTierIosLimitExceededError,
    EAS_BUILD_RESOURCE_CLASS_NOT_AVAILABLE_IN_FREE_TIER: errors_1.EasBuildResourceClassNotAvailableInFreeTierError,
    EAS_BUILD_LEGACY_RESOURCE_CLASS_NOT_AVAILABLE: errors_1.EasBuildLegacyResourceClassNotAvailableError,
    VALIDATION_ERROR: errors_1.RequestValidationError,
};
function handleBuildRequestError(error, platform) {
    log_1.default.debug(JSON.stringify(error.graphQLErrors, null, 2));
    const graphQLErrorCode = error?.graphQLErrors?.[0]?.extensions?.errorCode;
    if (graphQLErrorCode in SERVER_SIDE_DEFINED_ERRORS) {
        const ErrorClass = SERVER_SIDE_DEFINED_ERRORS[graphQLErrorCode];
        throw new ErrorClass(error?.graphQLErrors?.[0]?.message);
    }
    else if (graphQLErrorCode === 'EAS_BUILD_DOWN_FOR_MAINTENANCE') {
        throw new errors_1.EasBuildDownForMaintenanceError(`EAS Build is down for maintenance. Try again later. Check ${(0, log_1.link)('https://status.expo.dev/')} for updates.`);
    }
    else if (graphQLErrorCode === 'EAS_BUILD_TOO_MANY_PENDING_BUILDS') {
        throw new errors_1.EasBuildTooManyPendingBuildsError(`You have already reached the maximum number of pending ${platform_1.requestedPlatformDisplayNames[platform]} builds for your account. Try again later.`);
    }
    else if (error?.graphQLErrors) {
        const errorMessage = error.graphQLErrors
            .map((graphQLError) => {
            const requestIdLine = graphQLError?.extensions?.requestId
                ? `\nRequest ID: ${graphQLError.extensions.requestId}`
                : '';
            const errorMessageLine = graphQLError?.message
                ? `\nError message: ${graphQLError.message}`
                : '';
            return `${requestIdLine}${errorMessageLine}`;
        })
            .join('');
        throw new Error(`Build request failed. Make sure you are using the latest eas-cli version. If the problem persists, report the issue.${errorMessage}`);
    }
    throw error;
}
exports.handleBuildRequestError = handleBuildRequestError;
async function uploadProjectAsync(ctx) {
    let projectTarballPath;
    try {
        return await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => {
            log_1.default.newLine();
            log_1.default.log(`Compressing project files and uploading to EAS Build. ${(0, log_1.learnMore)('https://expo.fyi/eas-build-archive')}`);
            const projectTarball = await (0, repository_1.makeProjectTarballAsync)(ctx.vcsClient);
            if (projectTarball.size > 1024 * 1024 * 100) {
                log_1.default.warn(`Your project archive is ${(0, files_1.formatBytes)(projectTarball.size)}. You can reduce its size and the time it takes to upload by excluding files that are unnecessary for the build process in ${chalk_1.default.bold('.easignore')} file. ${(0, log_1.learnMore)('https://expo.fyi/eas-build-archive')}`);
            }
            if (projectTarball.size > 2 * 1024 * 1024 * 1024) {
                throw new Error('Project archive is too big. Maximum allowed size is 2GB.');
            }
            projectTarballPath = projectTarball.path;
            const [bucketKey, { metadataLocation }] = await Promise.all([
                (0, uploads_1.uploadFileAtPathToGCSAsync)(ctx.graphqlClient, generated_1.UploadSessionType.EasBuildGcsProjectSources, projectTarball.path, (0, progress_1.createProgressTracker)({
                    total: projectTarball.size,
                    message: ratio => `Uploading to EAS Build (${(0, files_1.formatBytes)(projectTarball.size * ratio)} / ${(0, files_1.formatBytes)(projectTarball.size)})`,
                    completedMessage: (duration) => `Uploaded to EAS ${chalk_1.default.dim(duration)}`,
                })),
                uploadMetadataFileAsync(projectTarball, ctx),
            ]);
            if (metadataLocation) {
                return { bucketKey, metadataLocation };
            }
            return { bucketKey };
        }, {
            attemptEvent: AnalyticsManager_1.BuildEvent.PROJECT_UPLOAD_ATTEMPT,
            successEvent: AnalyticsManager_1.BuildEvent.PROJECT_UPLOAD_SUCCESS,
            failureEvent: AnalyticsManager_1.BuildEvent.PROJECT_UPLOAD_FAIL,
            properties: ctx.analyticsEventProperties,
        });
    }
    catch (err) {
        let errMessage = 'Failed to upload the project tarball to EAS Build';
        if (err.message) {
            errMessage += `\n\nReason: ${err.message}`;
        }
        throw new errors_1.EasBuildProjectArchiveUploadError(errMessage);
    }
    finally {
        if (projectTarballPath) {
            await fs_extra_1.default.remove(projectTarballPath);
        }
    }
}
async function uploadMetadataFileAsync(projectTarball, ctx) {
    let projectMetadataFile = null;
    try {
        projectMetadataFile = await (0, repository_1.makeProjectMetadataFileAsync)(projectTarball.path);
        const metadataLocation = await (0, uploads_1.uploadFileAtPathToGCSAsync)(ctx.graphqlClient, generated_1.UploadSessionType.EasBuildGcsProjectMetadata, projectMetadataFile.path);
        return { metadataLocation };
    }
    catch (err) {
        let errMessage = 'Failed to upload metadata to EAS Build';
        if (err.message) {
            errMessage += `\n\nReason: ${err.message}`;
        }
        log_1.default.warn(errMessage);
        return { metadataLocation: null };
    }
    finally {
        if (projectMetadataFile) {
            await fs_extra_1.default.remove(projectMetadataFile.path);
        }
    }
}
async function sendBuildRequestAsync(builder, job, metadata, buildParams) {
    const { ctx } = builder;
    return await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => {
        if (log_1.default.isDebug) {
            log_1.default.log(`Starting ${platform_1.requestedPlatformDisplayNames[job.platform]} build`);
        }
        const { build, deprecationInfo } = await builder.sendBuildRequestAsync(ctx.projectId, job, metadata, buildParams);
        (0, printBuildInfo_1.printDeprecationWarnings)(deprecationInfo);
        return build;
    }, {
        attemptEvent: AnalyticsManager_1.BuildEvent.BUILD_REQUEST_ATTEMPT,
        successEvent: AnalyticsManager_1.BuildEvent.BUILD_REQUEST_SUCCESS,
        failureEvent: AnalyticsManager_1.BuildEvent.BUILD_REQUEST_FAIL,
        properties: ctx.analyticsEventProperties,
    });
}
async function waitForBuildEndAsync(graphqlClient, { buildIds, accountName }, { intervalSec = 10 } = {}) {
    let spinner;
    let originalSpinnerText;
    if (buildIds.length === 1) {
        log_1.default.log('Waiting for build to complete. You can press Ctrl+C to exit.');
        originalSpinnerText = 'Waiting for build to complete.';
        spinner = (0, ora_1.ora)(originalSpinnerText).start();
    }
    else {
        originalSpinnerText = 'Waiting for builds to complete. You can press Ctrl+C to exit.';
        spinner = (0, ora_1.ora)('Waiting for builds to complete. You can press Ctrl+C to exit.').start();
    }
    while (true) {
        const builds = await getBuildsSafelyAsync(graphqlClient, buildIds);
        const { refetch } = builds.length === 1
            ? await handleSingleBuildProgressAsync({ build: builds[0], accountName }, { spinner })
            : await handleMultipleBuildsProgressAsync({ builds }, { spinner, originalSpinnerText });
        if (!refetch) {
            return builds;
        }
        await (0, promise_1.sleepAsync)(intervalSec * 1000);
    }
}
exports.waitForBuildEndAsync = waitForBuildEndAsync;
async function getBuildsSafelyAsync(graphqlClient, buildIds) {
    const promises = buildIds.map(async (buildId) => {
        try {
            return await BuildQuery_1.BuildQuery.byIdAsync(graphqlClient, buildId, { useCache: false });
        }
        catch (err) {
            log_1.default.debug('Failed to fetch the build status', err);
            return null;
        }
    });
    return await Promise.all(promises);
}
let queueProgressBarStarted = false;
const queueProgressBar = new cli_progress_1.default.SingleBar({ format: '|{bar}| {estimatedWaitTime}' }, cli_progress_1.default.Presets.rect);
async function handleSingleBuildProgressAsync({ build, accountName, }, { spinner }) {
    if (build === null) {
        spinner.text = 'Could not fetch the build status. Check your network connection.';
        return { refetch: true };
    }
    if (queueProgressBarStarted && build?.status && build.status !== generated_1.BuildStatus.InQueue) {
        if (build.status === generated_1.BuildStatus.InProgress) {
            queueProgressBar.update(queueProgressBar.getTotal(), {
                estimatedWaitTime: '',
            });
        }
        queueProgressBar.stop();
        log_1.default.newLine();
        queueProgressBarStarted = false;
        spinner.start('Build is about to start');
    }
    switch (build.status) {
        case generated_1.BuildStatus.Finished:
            spinner.succeed('Build finished');
            return { refetch: false };
        case generated_1.BuildStatus.New:
            spinner.text = `Build is waiting to enter the queue. Check your concurrency limit at ${(0, log_1.link)(formatAccountSubscriptionsUrl(accountName))}.`;
            break;
        case generated_1.BuildStatus.InQueue: {
            spinner.text = 'Build queued...';
            const progressBarPayload = typeof build.estimatedWaitTimeLeftSeconds === 'number'
                ? { estimatedWaitTime: formatEstimatedWaitTime(build.estimatedWaitTimeLeftSeconds) }
                : { estimatedWaitTime: '' };
            if (!queueProgressBarStarted &&
                typeof build.initialQueuePosition === 'number' &&
                typeof build.queuePosition === 'number' &&
                typeof build.estimatedWaitTimeLeftSeconds === 'number') {
                spinner.stopAndPersist();
                if (build.priority !== generated_1.BuildPriority.High) {
                    log_1.default.newLine();
                    log_1.default.log('Start builds sooner in the priority queue.');
                    log_1.default.log(`Sign up for EAS Production or Enterprise at ${(0, log_1.link)(formatAccountSubscriptionsUrl(accountName))}`);
                }
                log_1.default.newLine();
                log_1.default.log(`Waiting in ${priorityToQueueDisplayName[build.priority]}`);
                queueProgressBar.start(build.initialQueuePosition + 1, build.initialQueuePosition - build.queuePosition + 1, progressBarPayload);
                queueProgressBarStarted = true;
            }
            if (typeof build.queuePosition === 'number') {
                queueProgressBar.update(build.queuePosition, progressBarPayload);
            }
            break;
        }
        case generated_1.BuildStatus.PendingCancel:
        case generated_1.BuildStatus.Canceled:
            spinner.fail('Build canceled');
            return { refetch: false };
        case generated_1.BuildStatus.InProgress:
            spinner.text = 'Build in progress...';
            break;
        case generated_1.BuildStatus.Errored:
            spinner.fail('Build failed');
            if (build.error) {
                return { refetch: false };
            }
            else {
                throw new Error('Standalone build failed!');
            }
        default:
            spinner.warn('Unknown status');
            throw new Error(`Unknown build status: ${build.status} - aborting!`);
    }
    return { refetch: true };
}
const priorityToQueueDisplayName = {
    [generated_1.BuildPriority.Normal]: 'Free tier queue',
    [generated_1.BuildPriority.NormalPlus]: 'Free tier queue',
    [generated_1.BuildPriority.High]: 'priority queue',
};
const statusToDisplayName = {
    [generated_1.BuildStatus.New]: 'waiting to enter the queue (concurrency limit reached)',
    [generated_1.BuildStatus.InQueue]: 'in queue',
    [generated_1.BuildStatus.InProgress]: 'in progress',
    [generated_1.BuildStatus.PendingCancel]: 'canceled',
    [generated_1.BuildStatus.Canceled]: 'canceled',
    [generated_1.BuildStatus.Finished]: 'finished',
    [generated_1.BuildStatus.Errored]: 'failed',
};
const platforms = [generated_1.AppPlatform.Android, generated_1.AppPlatform.Ios];
async function handleMultipleBuildsProgressAsync({ builds: maybeBuilds }, { spinner, originalSpinnerText }) {
    const buildCount = maybeBuilds.length;
    const builds = maybeBuilds.filter(isBuildFragment);
    const allFinished = builds.filter(build => build.status === generated_1.BuildStatus.Finished).length === buildCount;
    const allSettled = builds.filter(build => [
        generated_1.BuildStatus.Finished,
        generated_1.BuildStatus.Errored,
        generated_1.BuildStatus.Canceled,
        generated_1.BuildStatus.PendingCancel,
    ].includes(build.status)).length === buildCount;
    if (allSettled) {
        if (allFinished) {
            spinner.succeed(formatSettledBuildsText(builds));
        }
        else {
            spinner.fail(formatSettledBuildsText(builds));
        }
        return { refetch: false };
    }
    else {
        spinner.text = formatPendingBuildsText(originalSpinnerText, builds);
        return { refetch: true };
    }
}
function formatSettledBuildsText(builds) {
    return platforms
        .map(platform => {
        const build = (0, nullthrows_1.default)(builds.find(build => build.platform === platform), `Build for platform ${platform} must be defined in this context`);
        return `${platform_1.appPlatformEmojis[platform]} ${platform_1.appPlatformDisplayNames[platform]} build - status: ${chalk_1.default.bold(statusToDisplayName[build.status])}`;
    })
        .join('\n  ');
}
function formatPendingBuildsText(originalSpinnerText, builds) {
    return [
        originalSpinnerText,
        ...platforms.map(platform => {
            const build = builds.find(build => build.platform === platform);
            const status = build ? statusToDisplayName[build.status] : 'unknown';
            let extraInfo = '';
            if (build?.status === generated_1.BuildStatus.InQueue &&
                typeof build.initialQueuePosition === 'number' &&
                typeof build.queuePosition === 'number') {
                const percent = Math.floor(((build.initialQueuePosition - build.queuePosition + 1) /
                    (build.initialQueuePosition + 1)) *
                    100);
                const estimatedWaitTime = typeof build.estimatedWaitTimeLeftSeconds === 'number'
                    ? ` - ${formatEstimatedWaitTime(build.estimatedWaitTimeLeftSeconds)}`
                    : '';
                extraInfo = ` - queue progress: ${chalk_1.default.bold(`${percent}%`)}${estimatedWaitTime}`;
            }
            return `${platform_1.appPlatformEmojis[platform]} ${platform_1.appPlatformDisplayNames[platform]} build - status: ${chalk_1.default.bold(status)}${extraInfo}`;
        }),
    ].join('\n  ');
}
function isBuildFragment(maybeBuild) {
    return maybeBuild !== null;
}
function formatEstimatedWaitTime(estimatedWaitTimeLeftSeconds) {
    if (estimatedWaitTimeLeftSeconds < 5 * 60) {
        return 'starting soon...';
    }
    else {
        const n = Math.floor(estimatedWaitTimeLeftSeconds / (10 * 60)) + 1;
        return `starting in about ${n}0 minutes...`;
    }
}
function formatAccountSubscriptionsUrl(accountName) {
    return new URL(`/accounts/${accountName}/settings/subscriptions`, (0, api_1.getExpoWebsiteBaseUrl)()).toString();
}
async function createAndMaybeUploadFingerprintAsync(ctx) {
    const resolvedRuntimeVersion = await (0, resolveRuntimeVersionAsync_1.resolveRuntimeVersionAsync)({
        exp: ctx.exp,
        platform: ctx.platform,
        workflow: ctx.workflow,
        projectDir: ctx.projectDir,
        env: ctx.env,
        cwd: ctx.projectDir,
    });
    if (!resolvedRuntimeVersion) {
        return {};
    }
    /**
     * It's ok for fingerprintSources or runtimeVersion to be empty
     * fingerprintSources only exist if the project is using runtimeVersion.policy: fingerprint
     */
    if (!resolvedRuntimeVersion.fingerprint || !resolvedRuntimeVersion.runtimeVersion) {
        return {
            runtimeVersion: resolvedRuntimeVersion.runtimeVersion ?? undefined,
        };
    }
    return await (0, maybeUploadFingerprintAsync_1.maybeUploadFingerprintAsync)({
        runtimeVersion: resolvedRuntimeVersion.runtimeVersion,
        fingerprint: resolvedRuntimeVersion.fingerprint,
        graphqlClient: ctx.graphqlClient,
        localBuildMode: ctx.localBuildOptions.localBuildMode,
    });
}
