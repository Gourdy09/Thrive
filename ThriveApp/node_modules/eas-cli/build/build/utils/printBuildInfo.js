"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printUserError = exports.printDeprecationWarnings = exports.printBuildResults = exports.printLogsUrls = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const indent_string_1 = tslib_1.__importDefault(require("indent-string"));
const qrcode_terminal_1 = tslib_1.__importDefault(require("qrcode-terminal"));
const url_1 = require("./url");
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importStar(require("../../log"));
const platform_1 = require("../../platform");
function terminalLinkFallback(url, text) {
    return `${text} (${url})`;
}
const errorCodeToErrorMessageOverride = {
    EAS_BUILD_UNKNOWN_FASTLANE_ERROR: build => `The ${(0, log_1.link)((0, url_1.getBuildLogsUrl)(build, 'run-fastlane'), {
        text: '"Run fastlane"',
        fallback: terminalLinkFallback((0, url_1.getBuildLogsUrl)(build, 'run-fastlane'), '"Run fastlane"'),
    })} step failed with an unknown error. Refer to the ${(0, log_1.link)((0, url_1.getBuildLogsUrl)(build, 'xcode-logs'), {
        text: '"Xcode logs"',
        fallback: terminalLinkFallback((0, url_1.getBuildLogsUrl)(build, 'xcode-logs'), '"Xcode logs"'),
    })} phase for additional, more detailed logs`,
    EAS_BUILD_UNKNOWN_GRADLE_ERROR: build => `Gradle build failed with unknown error. See logs for the ${(0, log_1.link)((0, url_1.getBuildLogsUrl)(build, 'run-gradlew'), {
        text: '"Run gradlew"',
        fallback: terminalLinkFallback((0, url_1.getBuildLogsUrl)(build, 'run-gradlew'), '"Run gradlew"'),
    })} phase for more information.`,
};
function printLogsUrls(builds) {
    if (builds.length === 1) {
        log_1.default.log(`Build details: ${(0, log_1.link)((0, url_1.getBuildLogsUrl)(builds[0]))}`);
    }
    else {
        builds.forEach(build => {
            const logsUrl = (0, url_1.getBuildLogsUrl)(build);
            log_1.default.log(`${platform_1.appPlatformEmojis[build.platform]} ${platform_1.appPlatformDisplayNames[build.platform]} build details: ${(0, log_1.link)(logsUrl)}`);
        });
    }
}
exports.printLogsUrls = printLogsUrls;
function printBuildResults(builds) {
    if (builds.length === 1) {
        const [build] = builds;
        (0, assert_1.default)(build, 'Build should be defined');
        printBuildResult(build);
    }
    else {
        builds.filter(i => i).forEach(build => {
            printBuildResult(build);
        });
    }
}
exports.printBuildResults = printBuildResults;
function printBuildResult(build) {
    if (build.status === generated_1.BuildStatus.Errored) {
        log_1.default.addNewLineIfNone();
        const userError = build.error;
        log_1.default.error(`${platform_1.appPlatformEmojis[build.platform]} ${platform_1.appPlatformDisplayNames[build.platform]} build failed${userError ? ':' : ''}`);
        if (userError) {
            printUserError(userError, build);
        }
        return;
    }
    if ([generated_1.BuildStatus.Canceled, generated_1.BuildStatus.PendingCancel].includes(build.status)) {
        log_1.default.addNewLineIfNone();
        log_1.default.error(`${platform_1.appPlatformEmojis[build.platform]} ${platform_1.appPlatformDisplayNames[build.platform]} build was canceled`);
        return;
    }
    if (build.distribution === generated_1.DistributionType.Internal) {
        log_1.default.addNewLineIfNone();
        const logsUrl = (0, url_1.getBuildLogsUrl)(build);
        // It's tricky to install the .apk file directly on Android so let's fallback
        // to the build details page and let people press the button to download there
        const qrcodeUrl = build.platform === generated_1.AppPlatform.Ios ? (0, url_1.getInternalDistributionInstallUrl)(build) : logsUrl;
        qrcode_terminal_1.default.generate(qrcodeUrl, { small: true }, code => {
            log_1.default.log(`${(0, indent_string_1.default)(code, 2)}\n`);
        });
        log_1.default.log(`${platform_1.appPlatformEmojis[build.platform]} Open this link on your ${platform_1.appPlatformDisplayNames[build.platform]} devices (or scan the QR code) to install the app:`);
        log_1.default.log(`${(0, log_1.link)(logsUrl)}`);
    }
    else {
        // TODO: it looks like buildUrl could possibly be undefined, based on the code below.
        // we should account for this case better if it is possible
        const url = build.artifacts?.buildUrl;
        if (url) {
            log_1.default.addNewLineIfNone();
            log_1.default.log(`${platform_1.appPlatformEmojis[build.platform]} ${platform_1.appPlatformDisplayNames[build.platform]} app:`);
            log_1.default.log((0, log_1.link)(url));
        }
    }
}
function printDeprecationWarnings(deprecationInfo) {
    if (!deprecationInfo) {
        return;
    }
    if (deprecationInfo.type === generated_1.EasBuildDeprecationInfoType.Internal) {
        log_1.default.warn('This command is using API that soon will be deprecated. Upgrade EAS CLI.');
        log_1.default.warn("Changes won't affect your project config.");
        log_1.default.warn(deprecationInfo.message);
    }
    else if (deprecationInfo.type === generated_1.EasBuildDeprecationInfoType.UserFacing) {
        log_1.default.warn('This command is using API that soon will be deprecated.');
        log_1.default.warn(deprecationInfo.message);
    }
    else {
        log_1.default.warn('An unexpected warning was encountered. Report it as a bug:');
        log_1.default.warn(deprecationInfo);
    }
}
exports.printDeprecationWarnings = printDeprecationWarnings;
function printUserError(error, build) {
    const maybeErrorMessageOverride = maybeGetErrorMessageOverride(error, build);
    if (maybeErrorMessageOverride) {
        log_1.default.error(maybeErrorMessageOverride);
    }
    else {
        log_1.default.error(error.message);
        if (error.docsUrl) {
            log_1.default.error((0, log_1.learnMore)(error.docsUrl, { dim: false }));
        }
    }
}
exports.printUserError = printUserError;
function maybeGetErrorMessageOverride(error, build) {
    if (!(error.errorCode in errorCodeToErrorMessageOverride)) {
        return null;
    }
    return errorCodeToErrorMessageOverride[error.errorCode](build);
}
