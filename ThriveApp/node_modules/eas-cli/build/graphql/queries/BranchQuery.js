"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BranchQuery = void 0;
const tslib_1 = require("tslib");
const graphql_1 = require("graphql");
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const utils_1 = require("../../branch/utils");
const client_1 = require("../client");
const Update_1 = require("../types/Update");
const UpdateBranch_1 = require("../types/UpdateBranch");
const UpdateBranchBasicInfo_1 = require("../types/UpdateBranchBasicInfo");
exports.BranchQuery = {
    async getBranchByNameAsync(graphqlClient, { appId, name }) {
        const response = await (0, client_1.withErrorHandlingAsync)(graphqlClient
            .query((0, graphql_tag_1.default) `
            query ViewBranch($appId: String!, $name: String!) {
              app {
                byId(appId: $appId) {
                  id
                  updateBranchByName(name: $name) {
                    id
                    ...UpdateBranchBasicInfoFragment
                  }
                }
              }
            }
            ${(0, graphql_1.print)(UpdateBranchBasicInfo_1.UpdateBranchBasicInfoFragmentNode)}
          `, {
            appId,
            name,
        }, { additionalTypenames: ['UpdateBranch'] })
            .toPromise());
        const { updateBranchByName } = response.app.byId;
        if (!updateBranchByName) {
            throw new utils_1.BranchNotFoundError(`Could not find a branch named "${name}".`);
        }
        return updateBranchByName;
    },
    async getLatestUpdateIdOnBranchAsync(graphqlClient, { appId, branchName, platform, runtimeVersion, }) {
        const response = await (0, client_1.withErrorHandlingAsync)(graphqlClient
            .query((0, graphql_tag_1.default) `
            query ViewLatestUpdateOnBranch(
              $appId: String!
              $branchName: String!
              $platform: AppPlatform!
              $runtimeVersion: String!
            ) {
              app {
                byId(appId: $appId) {
                  id
                  updateBranchByName(name: $branchName) {
                    id
                    updates(
                      offset: 0
                      limit: 1
                      filter: { platform: $platform, runtimeVersions: [$runtimeVersion] }
                    ) {
                      id
                    }
                  }
                }
              }
            }
          `, {
            appId,
            branchName,
            platform,
            runtimeVersion,
        }, { additionalTypenames: ['UpdateBranch'] })
            .toPromise());
        const { updateBranchByName } = response.app.byId;
        if (!updateBranchByName) {
            throw new utils_1.BranchNotFoundError(`Could not find a branch named "${branchName}".`);
        }
        const latestUpdate = updateBranchByName.updates[0];
        if (!latestUpdate) {
            return null;
        }
        return latestUpdate.id;
    },
    async listBranchesOnAppAsync(graphqlClient, { appId, limit, offset }) {
        const data = await (0, client_1.withErrorHandlingAsync)(graphqlClient
            .query((0, graphql_tag_1.default) `
            query BranchesByAppQuery($appId: String!, $limit: Int!, $offset: Int!) {
              app {
                byId(appId: $appId) {
                  id
                  updateBranches(limit: $limit, offset: $offset) {
                    id
                    ...UpdateBranchFragment
                  }
                }
              }
            }
            ${(0, graphql_1.print)(UpdateBranch_1.UpdateBranchFragmentNode)}
          `, {
            appId,
            limit,
            offset,
        }, { additionalTypenames: ['UpdateBranch'] })
            .toPromise());
        return data?.app?.byId.updateBranches ?? [];
    },
    async listBranchesBasicInfoPaginatedOnAppAsync(graphqlClient, { appId, first, after, last, before }) {
        const response = await (0, client_1.withErrorHandlingAsync)(graphqlClient
            .query((0, graphql_tag_1.default) `
            query BranchesBasicPaginatedOnApp(
              $appId: String!
              $first: Int
              $after: String
              $last: Int
              $before: String
            ) {
              app {
                byId(appId: $appId) {
                  id
                  branchesPaginated(first: $first, after: $after, before: $before, last: $last) {
                    edges {
                      node {
                        id
                        ...UpdateBranchBasicInfoFragment
                      }
                      cursor
                    }
                    pageInfo {
                      hasNextPage
                      hasPreviousPage
                      startCursor
                      endCursor
                    }
                  }
                }
              }
            }
            ${(0, graphql_1.print)(UpdateBranchBasicInfo_1.UpdateBranchBasicInfoFragmentNode)}
          `, { appId, first, after, last, before }, { additionalTypenames: ['UpdateBranch'] })
            .toPromise());
        const { branchesPaginated } = response.app.byId;
        if (!branchesPaginated) {
            throw new Error(`Could not find channels on project with id ${appId}`);
        }
        return branchesPaginated;
    },
    async listBranchesOnChannelAsync(graphqlClient, { appId, channelName, offset, limit }) {
        const response = await (0, client_1.withErrorHandlingAsync)(graphqlClient
            .query((0, graphql_tag_1.default) `
            query ViewBranchesOnUpdateChannel(
              $appId: String!
              $channelName: String!
              $offset: Int!
              $limit: Int!
            ) {
              app {
                byId(appId: $appId) {
                  id
                  updateChannelByName(name: $channelName) {
                    id
                    updateBranches(offset: $offset, limit: $limit) {
                      id
                      name
                      updateGroups(offset: 0, limit: 1) {
                        id
                        ...UpdateFragment
                      }
                    }
                  }
                }
              }
            }
            ${(0, graphql_1.print)(Update_1.UpdateFragmentNode)}
          `, { appId, channelName, offset, limit }, { additionalTypenames: ['UpdateChannel', 'UpdateBranch', 'Update'] })
            .toPromise());
        const { updateChannelByName } = response.app.byId;
        if (!updateChannelByName) {
            throw new Error(`Could not find channels with the name ${channelName}`);
        }
        return updateChannelByName.updateBranches;
    },
};
