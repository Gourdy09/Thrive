"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeShallowCopyAsync = exports.Ignore = exports.getRootPath = void 0;
const tslib_1 = require("tslib");
const fast_glob_1 = tslib_1.__importDefault(require("fast-glob"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const path_1 = tslib_1.__importDefault(require("path"));
const EASIGNORE_FILENAME = '.easignore';
const GITIGNORE_FILENAME = '.gitignore';
const DEFAULT_IGNORE = `
.git
node_modules
`;
function getRootPath() {
    const rootPath = process.env.EAS_PROJECT_ROOT ?? process.cwd();
    if (!path_1.default.isAbsolute(rootPath)) {
        return path_1.default.resolve(process.cwd(), rootPath);
    }
    return rootPath;
}
exports.getRootPath = getRootPath;
/**
 * Ignore wraps the 'ignore' package to support multiple .gitignore files
 * in subdirectories.
 *
 * Inconsistencies with git behavior:
 * - if parent .gitignore has ignore rule and child has exception to that rule,
 *   file will still be ignored,
 * - node_modules is always ignored,
 * - if .easignore exists, .gitignore files are not used.
 */
class Ignore {
    constructor(rootDir) {
        this.rootDir = rootDir;
        this.ignoreMapping = [];
    }
    async initIgnoreAsync() {
        const easIgnorePath = path_1.default.join(this.rootDir, EASIGNORE_FILENAME);
        if (await fs_extra_1.default.pathExists(easIgnorePath)) {
            this.ignoreMapping = [
                ['', (0, ignore_1.default)().add(DEFAULT_IGNORE)],
                ['', (0, ignore_1.default)().add(await fs_extra_1.default.readFile(easIgnorePath, 'utf-8'))],
            ];
            return;
        }
        const ignoreFilePaths = (await (0, fast_glob_1.default)(`**/${GITIGNORE_FILENAME}`, {
            cwd: this.rootDir,
            ignore: ['node_modules'],
            followSymbolicLinks: false,
        }))
            // ensure that parent dir is before child directories
            .sort((a, b) => a.length - b.length && a.localeCompare(b));
        const ignoreMapping = await Promise.all(ignoreFilePaths.map(async (filePath) => {
            return [
                filePath.slice(0, filePath.length - GITIGNORE_FILENAME.length),
                (0, ignore_1.default)().add(await fs_extra_1.default.readFile(path_1.default.join(this.rootDir, filePath), 'utf-8')),
            ];
        }));
        this.ignoreMapping = [['', (0, ignore_1.default)().add(DEFAULT_IGNORE)], ...ignoreMapping];
    }
    ignores(relativePath) {
        for (const [prefix, ignore] of this.ignoreMapping) {
            if (relativePath.startsWith(prefix) && ignore.ignores(relativePath.slice(prefix.length))) {
                return true;
            }
        }
        return false;
    }
}
exports.Ignore = Ignore;
async function makeShallowCopyAsync(src, dst) {
    const ignore = new Ignore(src);
    await ignore.initIgnoreAsync();
    await fs_extra_1.default.copy(src, dst, {
        filter: (srcFilePath) => {
            if (srcFilePath === src) {
                return true;
            }
            return !ignore.ignores(path_1.default.relative(src, srcFilePath));
        },
    });
}
exports.makeShallowCopyAsync = makeShallowCopyAsync;
