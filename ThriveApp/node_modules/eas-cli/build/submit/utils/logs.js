"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.displayLogsAsync = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const errors_1 = require("./errors");
const fetch_1 = tslib_1.__importDefault(require("../../fetch"));
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../../log"));
async function displayLogsAsync(submission, { verbose = false, moreSubmissions = false } = {}) {
    let printedUnknownError = false;
    if (submission.status === generated_1.SubmissionStatus.Errored && submission.error) {
        printedUnknownError = (0, errors_1.printSubmissionError)(submission.error);
    }
    else if (submission.status === generated_1.SubmissionStatus.Canceled && moreSubmissions) {
        log_1.default.newLine();
        log_1.default.error('Submission has been canceled');
    }
    if (printedUnknownError || verbose) {
        await downloadAndPrintSubmissionLogsAsync(submission);
    }
}
exports.displayLogsAsync = displayLogsAsync;
async function downloadAndPrintSubmissionLogsAsync(submission) {
    for (const logFile of submission.logFiles) {
        const response = await (0, fetch_1.default)(logFile);
        const logs = parseLogs(await response.text());
        log_1.default.addNewLineIfNone();
        const prefix = chalk_1.default.blueBright('[logs] ');
        for (const { level, msg } of logs) {
            const msgWithPrefix = `${prefix}${msg}`;
            if (level === 'error') {
                log_1.default.error(msgWithPrefix);
            }
            else if (level === 'warn') {
                log_1.default.warn(msgWithPrefix);
            }
            else {
                log_1.default.log(msgWithPrefix);
            }
        }
    }
}
function parseLogs(logs) {
    const lines = logs.split('\n');
    const result = [];
    for (const line of lines) {
        let parsedLine;
        try {
            parsedLine = JSON.parse(line);
        }
        catch {
            continue;
        }
        let level;
        const { level: levelNumber, msg } = parsedLine;
        if (levelNumber >= 50) {
            level = 'error';
        }
        else if (levelNumber >= 40) {
            level = 'warn';
        }
        else {
            level = 'info';
        }
        result.push({ level, msg });
    }
    return result;
}
