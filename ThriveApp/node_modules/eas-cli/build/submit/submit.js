"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exitWithNonZeroCodeIfSomeSubmissionsDidntFinish = exports.waitToCompleteAsync = exports.submitAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const AndroidSubmitCommand_1 = tslib_1.__importDefault(require("./android/AndroidSubmitCommand"));
const IosSubmitCommand_1 = tslib_1.__importDefault(require("./ios/IosSubmitCommand"));
const logs_1 = require("./utils/logs");
const wait_1 = require("./utils/wait");
const AnalyticsManager_1 = require("../analytics/AnalyticsManager");
const common_1 = require("../analytics/common");
const generated_1 = require("../graphql/generated");
const log_1 = tslib_1.__importStar(require("../log"));
const platform_1 = require("../platform");
async function submitAsync(ctx) {
    return await (0, common_1.withAnalyticsAsync)(ctx.analytics, async () => {
        const command = ctx.platform === eas_build_job_1.Platform.ANDROID
            ? new AndroidSubmitCommand_1.default(ctx)
            : new IosSubmitCommand_1.default(ctx);
        const submitter = await command.runAsync();
        return await submitter.submitAsync();
    }, {
        attemptEvent: AnalyticsManager_1.SubmissionEvent.SUBMIT_COMMAND_ATTEMPT,
        successEvent: AnalyticsManager_1.SubmissionEvent.SUBMIT_COMMAND_SUCCESS,
        failureEvent: AnalyticsManager_1.SubmissionEvent.SUBMIT_COMMAND_FAIL,
        properties: ctx.analyticsEventProperties,
    });
}
exports.submitAsync = submitAsync;
async function waitToCompleteAsync(graphqlClient, submissions, { verbose = false } = {}) {
    log_1.default.newLine();
    const completedSubmissions = await (0, wait_1.waitForSubmissionsEndAsync)(graphqlClient, submissions);
    const moreSubmissions = completedSubmissions.length > 1;
    if (moreSubmissions) {
        log_1.default.newLine();
    }
    for (const submission of completedSubmissions) {
        if (moreSubmissions) {
            log_1.default.log(`${platform_1.appPlatformEmojis[submission.platform]} ${chalk_1.default.bold(`${platform_1.appPlatformDisplayNames[submission.platform]} submission`)}`);
        }
        if (submission.platform === generated_1.AppPlatform.Android) {
            printInstructionsForAndroidSubmission(submission);
        }
        else {
            printInstructionsForIosSubmission(submission);
        }
        await (0, logs_1.displayLogsAsync)(submission, { verbose, moreSubmissions });
        if (moreSubmissions) {
            log_1.default.newLine();
        }
    }
    return completedSubmissions;
}
exports.waitToCompleteAsync = waitToCompleteAsync;
function printInstructionsForAndroidSubmission(submission) {
    if (submission.status === generated_1.SubmissionStatus.Finished) {
        log_1.default.addNewLineIfNone();
        log_1.default.log('All done!');
    }
}
function printInstructionsForIosSubmission(submission) {
    if (submission.status === generated_1.SubmissionStatus.Finished) {
        const logMsg = [
            chalk_1.default.bold('Your binary has been successfully uploaded to App Store Connect!'),
            '- It is now being processed by Apple - you will receive an email when the processing finishes.',
            '- It usually takes about 5-10 minutes depending on how busy Apple servers are.',
            // ascAppIdentifier should be always available for ios submissions but check it anyway
            submission.iosConfig?.ascAppIdentifier &&
                `- When it's done, you can see your build here: ${(0, log_1.link)(`https://appstoreconnect.apple.com/apps/${submission.iosConfig?.ascAppIdentifier}/testflight/ios`)}`,
        ].join('\n');
        log_1.default.addNewLineIfNone();
        log_1.default.log(logMsg);
    }
}
function exitWithNonZeroCodeIfSomeSubmissionsDidntFinish(submissions) {
    const nonFinishedSubmissions = submissions.filter(({ status }) => status !== generated_1.SubmissionStatus.Finished);
    if (nonFinishedSubmissions.length > 0) {
        process.exit(1);
    }
}
exports.exitWithNonZeroCodeIfSomeSubmissionsDidntFinish = exitWithNonZeroCodeIfSomeSubmissionsDidntFinish;
