"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const eas_json_1 = require("@expo/eas-json");
const results_1 = require("@expo/results");
const AndroidSubmitter_1 = tslib_1.__importDefault(require("./AndroidSubmitter"));
const ServiceAccountSource_1 = require("./ServiceAccountSource");
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../../log"));
const applicationId_1 = require("../../project/android/applicationId");
const capitalize_1 = tslib_1.__importDefault(require("../../utils/expodash/capitalize"));
const ArchiveSource_1 = require("../ArchiveSource");
const commons_1 = require("../commons");
class AndroidSubmitCommand {
    constructor(ctx) {
        this.ctx = ctx;
    }
    async runAsync() {
        log_1.default.addNewLineIfNone();
        const archiveSource = this.resolveArchiveSource();
        if (!archiveSource.ok) {
            log_1.default.error(archiveSource.reason?.message);
            throw new Error('Submission failed');
        }
        const archiveSourceValue = archiveSource.enforceValue();
        const archive = await (0, ArchiveSource_1.getArchiveAsync)({
            graphqlClient: this.ctx.graphqlClient,
            platform: eas_build_job_1.Platform.ANDROID,
            projectId: this.ctx.projectId,
            nonInteractive: this.ctx.nonInteractive,
        }, archiveSourceValue);
        const archiveProfile = archive.sourceType === ArchiveSource_1.ArchiveSourceType.build ? archive.build.buildProfile : undefined;
        if (archiveProfile && !this.ctx.specifiedProfile) {
            this.ctx = await (0, commons_1.refreshContextSubmitProfileAsync)(this.ctx, archiveProfile);
        }
        const submissionOptions = await this.getAndroidSubmissionOptionsAsync(archiveSourceValue);
        const submitter = new AndroidSubmitter_1.default(this.ctx, submissionOptions, archive);
        return submitter;
    }
    async getAndroidSubmissionOptionsAsync(archiveSource) {
        const track = this.resolveTrack();
        const releaseStatus = this.resolveReleaseStatus();
        const rollout = this.resolveRollout();
        const serviceAccountSource = await this.resolveServiceAccountSourceAsync();
        const errored = [track, releaseStatus, serviceAccountSource, rollout].filter(r => !r.ok);
        if (errored.length > 0) {
            const message = errored.map(err => err.reason?.message).join('\n');
            log_1.default.error(message);
            throw new Error('Submission failed');
        }
        return {
            projectId: this.ctx.projectId,
            track: track.enforceValue(),
            releaseStatus: releaseStatus.enforceValue(),
            rollout: rollout.enforceValue(),
            archiveSource,
            serviceAccountSource: serviceAccountSource.enforceValue(),
            changesNotSentForReview: this.ctx.profile.changesNotSentForReview,
        };
    }
    async maybeGetAndroidPackageFromCurrentProjectAsync() {
        try {
            return (0, results_1.result)(await (0, applicationId_1.getApplicationIdAsync)(this.ctx.projectDir, this.ctx.exp, this.ctx.vcsClient));
        }
        catch (error) {
            if (error instanceof applicationId_1.AmbiguousApplicationIdError) {
                log_1.default.warn('"applicationId" is ambiguous, specify it via "applicationId" field in the submit profile in the eas.json.');
                return (0, results_1.result)(null);
            }
            return (0, results_1.result)(new Error(`Failed to resolve applicationId in Android project: ${error.message}.`));
        }
    }
    resolveTrack() {
        const { track } = this.ctx.profile;
        if (!track) {
            return (0, results_1.result)(generated_1.SubmissionAndroidTrack.Internal);
        }
        const capitalizedTrack = (0, capitalize_1.default)(track);
        if (capitalizedTrack in generated_1.SubmissionAndroidTrack) {
            return (0, results_1.result)(generated_1.SubmissionAndroidTrack[capitalizedTrack]);
        }
        else {
            return (0, results_1.result)(new Error(`Unsupported track: ${track} (valid options: ${Object.keys(eas_json_1.AndroidReleaseTrack).join(', ')})`));
        }
    }
    resolveReleaseStatus() {
        const { releaseStatus } = this.ctx.profile;
        if (!releaseStatus) {
            return (0, results_1.result)(generated_1.SubmissionAndroidReleaseStatus.Completed);
        }
        const capitalizedReleaseStatus = (0, capitalize_1.default)(releaseStatus);
        if (capitalizedReleaseStatus in generated_1.SubmissionAndroidReleaseStatus) {
            return (0, results_1.result)(generated_1.SubmissionAndroidReleaseStatus[capitalizedReleaseStatus]);
        }
        else {
            return (0, results_1.result)(new Error(`Unsupported release status: ${releaseStatus} (valid options: ${Object.keys(eas_json_1.AndroidReleaseStatus).join(', ')})`));
        }
    }
    resolveRollout() {
        const { rollout } = this.ctx.profile;
        return (0, results_1.result)(rollout);
    }
    resolveArchiveSource() {
        try {
            return (0, results_1.result)((0, commons_1.resolveArchiveSource)(this.ctx));
        }
        catch (err) {
            return (0, results_1.result)(err);
        }
    }
    async resolveServiceAccountSourceAsync() {
        const { serviceAccountKeyPath } = this.ctx.profile;
        if (serviceAccountKeyPath) {
            return (0, results_1.result)({
                sourceType: ServiceAccountSource_1.ServiceAccountSourceType.path,
                path: serviceAccountKeyPath,
            });
        }
        let androidApplicationIdentifier = this.ctx.applicationIdentifierOverride ?? this.ctx.profile.applicationId;
        if (!androidApplicationIdentifier) {
            const androidApplicationIdentifierResult = await this.maybeGetAndroidPackageFromCurrentProjectAsync();
            if (!androidApplicationIdentifierResult.ok) {
                return (0, results_1.result)(androidApplicationIdentifierResult.reason);
            }
            const androidApplicationIdentifierValue = androidApplicationIdentifierResult.enforceValue();
            if (androidApplicationIdentifierValue) {
                androidApplicationIdentifier = androidApplicationIdentifierValue;
            }
        }
        return (0, results_1.result)({
            sourceType: ServiceAccountSource_1.ServiceAccountSourceType.credentialsService,
            androidApplicationIdentifier,
        });
    }
}
exports.default = AndroidSubmitCommand;
