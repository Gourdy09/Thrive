"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManageRollout = exports.ManageRolloutActions = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const EditRollout_1 = require("./EditRollout");
const EndRollout_1 = require("./EndRollout");
const ChannelQuery_1 = require("../../graphql/queries/ChannelQuery");
const prompts_1 = require("../../prompts");
const branch_mapping_1 = require("../branch-mapping");
const utils_1 = require("../utils");
var ManageRolloutActions;
(function (ManageRolloutActions) {
    ManageRolloutActions["EDIT"] = "Edit";
    ManageRolloutActions["END"] = "End";
    ManageRolloutActions["VIEW"] = "View";
    ManageRolloutActions["GO_BACK"] = "Go back";
})(ManageRolloutActions || (exports.ManageRolloutActions = ManageRolloutActions = {}));
/**
 * Manage a rollout for the project.
 */
class ManageRollout {
    constructor(channelInfo, options) {
        this.channelInfo = channelInfo;
        this.options = options;
    }
    async runAsync(ctx) {
        const { nonInteractive } = ctx;
        if (nonInteractive) {
            throw new Error(`rollout selection cannot be run in non-interactive mode.`);
        }
        const channelObject = await this.getChannelObjectAsync(ctx);
        (0, utils_1.printRollout)(channelObject);
        const action = this.options.action ?? (await this.selectActionAsync());
        switch (action) {
            case ManageRolloutActions.EDIT:
                return new EditRollout_1.EditRollout(this.channelInfo, this.options);
            case ManageRolloutActions.END:
                return new EndRollout_1.EndRollout(this.channelInfo, this.options);
            case ManageRolloutActions.VIEW:
                // Rollout is automatically printed in interactive mode
                return new Noop();
            case ManageRolloutActions.GO_BACK:
                (0, assert_1.default)(this.options.callingAction, 'calling action must be defined');
                return this.options.callingAction;
        }
    }
    async selectActionAsync() {
        const manageOptions = [ManageRolloutActions.EDIT, ManageRolloutActions.END];
        if (this.options.callingAction) {
            manageOptions.push(ManageRolloutActions.GO_BACK);
        }
        const { manageOption: selectedManageOption } = await (0, prompts_1.promptAsync)({
            type: 'select',
            name: 'manageOption',
            message: `What would you like to do?`,
            choices: manageOptions.map(manageOption => ({
                value: manageOption,
                title: manageOption,
            })),
        });
        return selectedManageOption;
    }
    async getChannelObjectAsync(ctx) {
        const { graphqlClient, app } = ctx;
        const { projectId } = app;
        if (!(0, branch_mapping_1.isRollout)(this.channelInfo)) {
            throw new Error(`The channel ${chalk_1.default.bold(this.channelInfo.name)} is not a rollout. To manage a rollout, you must specify a channel with an ongoing rollout.`);
        }
        const rolloutInfo = (0, branch_mapping_1.getRolloutInfo)(this.channelInfo);
        return await ChannelQuery_1.ChannelQuery.viewUpdateChannelAsync(graphqlClient, {
            appId: projectId,
            channelName: this.channelInfo.name,
            ...((0, branch_mapping_1.isConstrainedRolloutInfo)(rolloutInfo)
                ? { filter: { runtimeVersions: [rolloutInfo.runtimeVersion] } }
                : {}),
        });
    }
}
exports.ManageRollout = ManageRollout;
class Noop {
    async runAsync() { }
}
