"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditRollout = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const edit_1 = require("../../commands/channel/edit");
const ChannelQuery_1 = require("../../graphql/queries/ChannelQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const prompts_1 = require("../../prompts");
const branch_mapping_1 = require("../branch-mapping");
const utils_1 = require("../utils");
function isNonInteractiveOptions(options) {
    return !!options.percent;
}
function assertNonInteractiveOptions(options) {
    (0, assert_1.default)(isNonInteractiveOptions(options), '--percent is required for editing a rollout in non-interactive mode.');
}
/**
 * Edit an existing rollout for the project.
 */
class EditRollout {
    constructor(channelInfo, options = {}) {
        this.channelInfo = channelInfo;
        this.options = options;
    }
    async runAsync(ctx) {
        const { nonInteractive, graphqlClient } = ctx;
        if (nonInteractive) {
            assertNonInteractiveOptions(this.options);
        }
        const channelObject = await this.getChannelObjectAsync(ctx);
        const rollout = (0, branch_mapping_1.getRollout)(channelObject);
        const { rolledOutBranch, defaultBranch } = rollout;
        const promptMessage = `What percent of users should be rolled out to the ${rolledOutBranch.name} branch ?`;
        const percent = this.options.percent ?? (await (0, utils_1.promptForRolloutPercentAsync)({ promptMessage }));
        if (percent === 0 || percent === 100) {
            log_1.default.warn(`Editing the percent to ${percent} will not end the rollout. You'll need to end the rollout from the main menu.`);
        }
        const oldBranchMapping = (0, branch_mapping_1.getRolloutBranchMapping)(channelObject.branchMapping);
        const newBranchMapping = (0, branch_mapping_1.editRolloutBranchMapping)(oldBranchMapping, percent);
        log_1.default.newLine();
        log_1.default.log(`üìù ${chalk_1.default.bold(percent)}% of users will be rolled out to the ${chalk_1.default.bold(rolledOutBranch.name)} branch and ${chalk_1.default.bold(100 - percent)}% will remain on the ${chalk_1.default.bold(defaultBranch.name)} branch.`);
        const confirmEdit = await this.confirmEditAsync(ctx);
        if (!confirmEdit) {
            throw new Error('Aborting...');
        }
        const newChannelInfo = await (0, edit_1.updateChannelBranchMappingAsync)(graphqlClient, {
            channelId: channelObject.id,
            branchMapping: JSON.stringify(newBranchMapping),
        });
        log_1.default.addNewLineIfNone();
        log_1.default.log(`‚úÖ Successfuly updated rollout`);
        return newChannelInfo;
    }
    async confirmEditAsync(ctx) {
        const { nonInteractive } = ctx;
        if (nonInteractive) {
            return true;
        }
        return await (0, prompts_1.confirmAsync)({
            message: `Confirm changes?`,
        });
    }
    async getChannelObjectAsync(ctx) {
        const { graphqlClient, app } = ctx;
        const { projectId } = app;
        if (!(0, branch_mapping_1.isRollout)(this.channelInfo)) {
            throw new Error(`The channel ${chalk_1.default.bold(this.channelInfo.name)} is not a rollout. To end a rollout, you must specify a channel with an ongoing rollout.`);
        }
        const rolloutInfo = (0, branch_mapping_1.getRolloutInfo)(this.channelInfo);
        return await ChannelQuery_1.ChannelQuery.viewUpdateChannelAsync(graphqlClient, {
            appId: projectId,
            channelName: this.channelInfo.name,
            ...((0, branch_mapping_1.isConstrainedRolloutInfo)(rolloutInfo)
                ? { filter: { runtimeVersions: [rolloutInfo.runtimeVersion] } }
                : {}),
        });
    }
}
exports.EditRollout = EditRollout;
