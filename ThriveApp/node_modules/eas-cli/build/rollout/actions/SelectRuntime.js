"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectRuntime = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const utils_1 = require("../../eas-update/utils");
const RuntimeQuery_1 = require("../../graphql/queries/RuntimeQuery");
const UpdateQuery_1 = require("../../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importStar(require("../../log"));
const prompts_1 = require("../../prompts");
const relay_1 = require("../../utils/relay");
const utils_2 = require("../utils");
/**
 * Select a runtime from a branch
 */
class SelectRuntime {
    constructor(branchInfo, options = {}) {
        this.branchInfo = branchInfo;
        this.options = options;
        this.printedType = options.anotherBranchToIntersectRuntimesBy
            ? `compatible runtime`
            : `runtime`;
    }
    warnNoRuntime() {
        if (this.options.anotherBranchToIntersectRuntimesBy) {
            const intersectBranchName = this.options.anotherBranchToIntersectRuntimesBy.name;
            log_1.default.warn(`‚ö†Ô∏è  Branches ${this.branchInfo.name} and ${intersectBranchName} dont have any updates with the same runtime.`);
            log_1.default.warn(`Your updates could be misconfigured. ${(0, log_1.learnMore)('https://expo.fyi/eas-update-rollouts')}`);
        }
        else {
            // no runtime on branch means no updates published on branch
            log_1.default.warn(`‚ö†Ô∏è  There are no updates published on branch ${this.branchInfo.name}.`);
        }
    }
    formatCantFindRuntime() {
        return `üïµÔ∏è Not finding the update you were looking for? ${(0, log_1.learnMore)('https://expo.fyi/eas-update-rollouts')}`;
    }
    async runAsync(ctx) {
        const { nonInteractive, graphqlClient, app } = ctx;
        const { projectId } = app;
        if (nonInteractive) {
            throw new utils_1.NonInteractiveError(`runtime selection cannot be run in non-interactive mode.`);
        }
        const newestRuntimeConnection = await this.getNewestRuntimeAsync(graphqlClient, {
            appId: projectId,
            branchName: this.branchInfo.name,
            anotherBranchIdToIntersectRuntimesBy: this.options.anotherBranchToIntersectRuntimesBy?.id,
        });
        if (newestRuntimeConnection.edges.length === 0) {
            log_1.default.addNewLineIfNone();
            this.warnNoRuntime();
            return null;
        }
        const onlyOneRuntime = newestRuntimeConnection.edges.length === 1 && !newestRuntimeConnection.pageInfo.hasNextPage;
        log_1.default.log(`‚úÖ ${beginSentence(this.printedType)}${onlyOneRuntime ? '' : 's'} detected`);
        if (onlyOneRuntime) {
            const runtime = newestRuntimeConnection.edges[0].node;
            const formattedRuntimeWithGroup = await this.displayLatestUpdateGroupAsync({
                graphqlClient,
                appId: projectId,
                branchName: this.branchInfo.name,
                runtime,
            });
            log_1.default.addNewLineIfNone();
            log_1.default.log(formattedRuntimeWithGroup);
            log_1.default.addNewLineIfNone();
            const useRuntime = await (0, prompts_1.confirmAsync)({
                message: `Target ${this.printedType} ${chalk_1.default.bold(runtime.version)}?`,
            });
            if (useRuntime) {
                return runtime.version;
            }
            else {
                log_1.default.newLine();
                log_1.default.warn(this.formatCantFindRuntime());
                return null;
            }
        }
        log_1.default.log(this.formatCantFindRuntime());
        const selectedRuntime = await this.selectRuntimesAsync(graphqlClient, {
            appId: projectId,
        });
        if (!selectedRuntime) {
            throw new Error(`No ${this.printedType} selected`);
        }
        return selectedRuntime.version;
    }
    async getNewestRuntimeAsync(graphqlClient, { appId, branchName, anotherBranchIdToIntersectRuntimesBy, }) {
        return await RuntimeQuery_1.RuntimeQuery.getRuntimesOnBranchAsync(graphqlClient, {
            appId,
            name: branchName,
            first: 1,
            filter: {
                branchId: anotherBranchIdToIntersectRuntimesBy,
            },
        });
    }
    async displayLatestUpdateGroupAsync({ graphqlClient, appId, branchName, runtime, }) {
        const updateGroups = await UpdateQuery_1.UpdateQuery.viewUpdateGroupsOnBranchAsync(graphqlClient, {
            appId,
            branchName,
            limit: 1,
            offset: 0,
            filter: {
                runtimeVersions: [runtime.version],
            },
        });
        (0, assert_1.default)(updateGroups.length < 2, `Expected at most one update group. Received: ${JSON.stringify(updateGroups)}`);
        return (0, utils_2.formatRuntimeWithUpdateGroup)(updateGroups[0], runtime, branchName);
    }
    async selectRuntimesAsync(graphqlClient, { appId, batchSize = 5, }) {
        const queryAsync = async (queryParams) => {
            return await RuntimeQuery_1.RuntimeQuery.getRuntimesOnBranchAsync(graphqlClient, {
                appId,
                name: this.branchInfo.name,
                first: queryParams.first,
                after: queryParams.after,
                last: queryParams.last,
                before: queryParams.before,
                filter: {
                    branchId: this.options.anotherBranchToIntersectRuntimesBy?.id,
                },
            });
        };
        const getTitleAsync = async (runtime) => {
            return await this.displayLatestUpdateGroupAsync({
                graphqlClient,
                appId,
                branchName: this.branchInfo.name,
                runtime,
            });
        };
        return await (0, relay_1.selectPaginatedAsync)({
            queryAsync,
            getTitleAsync,
            printedType: 'target runtime',
            pageSize: batchSize,
        });
    }
}
exports.SelectRuntime = SelectRuntime;
function beginSentence(phrase) {
    if (typeof phrase !== 'string' || phrase.length === 0) {
        return phrase; // Return the input without any modification if it's not a string or empty
    }
    return phrase.charAt(0).toUpperCase() + phrase.slice(1);
}
