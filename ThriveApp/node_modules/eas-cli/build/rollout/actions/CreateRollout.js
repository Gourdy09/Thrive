"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateRollout = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const SelectRuntime_1 = require("./SelectRuntime");
const SelectBranch_1 = require("../../branch/actions/SelectBranch");
const branch_mapping_1 = require("../../channel/branch-mapping");
const utils_1 = require("../../channel/utils");
const edit_1 = require("../../commands/channel/edit");
const BranchQuery_1 = require("../../graphql/queries/BranchQuery");
const ChannelQuery_1 = require("../../graphql/queries/ChannelQuery");
const UpdateQuery_1 = require("../../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const resolveRuntimeVersionAsync_1 = require("../../project/resolveRuntimeVersionAsync");
const workflow_1 = require("../../project/workflow");
const prompts_1 = require("../../prompts");
const filter_1 = require("../../utils/expodash/filter");
const branch_mapping_2 = require("../branch-mapping");
const utils_2 = require("../utils");
function isNonInteractiveOptions(options) {
    return !!options.branchNameToRollout && !!options.percent && !!options.runtimeVersion;
}
function assertNonInteractiveOptions(options) {
    (0, assert_1.default)(isNonInteractiveOptions(options), '--branch, --percent and --runtime-version are required for creating a rollout in non-interactive mode.');
}
/**
 * Create a rollout for the project.
 */
class CreateRollout {
    constructor(channelInfo, options = {}) {
        this.channelInfo = channelInfo;
        this.options = options;
    }
    async runAsync(ctx) {
        const { branchNameToRollout } = this.options;
        const { nonInteractive, graphqlClient } = ctx;
        if (nonInteractive) {
            assertNonInteractiveOptions(this.options);
        }
        if ((0, branch_mapping_2.isRollout)(this.channelInfo)) {
            throw new Error(`A rollout is already in progress for channel ${this.channelInfo.name}`);
        }
        if ((0, branch_mapping_1.hasEmptyBranchMap)(this.channelInfo)) {
            throw new Error(`Your channel needs to be linked to a branch before a rollout can be created. Do this by running 'eas channel:edit'`);
        }
        if (!(0, branch_mapping_1.hasStandardBranchMap)(this.channelInfo)) {
            throw new Error(`You have a custom branch mapping. Map your channel to a single branch before creating a rollout. Received: ${this.channelInfo.branchMapping}`);
        }
        const defaultBranchId = (0, branch_mapping_1.getStandardBranchId)(this.channelInfo);
        const branchInfoToRollout = branchNameToRollout
            ? await this.resolveBranchNameAsync(ctx, branchNameToRollout)
            : await this.selectBranchAsync(ctx, defaultBranchId);
        if (branchInfoToRollout.id === defaultBranchId) {
            throw new Error(`Channel ${this.channelInfo.name} is already mapped to branch ${branchInfoToRollout.name}.`);
        }
        const runtimeVersion = this.options.runtimeVersion ??
            (await this.selectRuntimeVersionAsync(ctx, branchInfoToRollout, defaultBranchId));
        log_1.default.newLine();
        const promptMessage = `What percent of users should be rolled out to branch ${branchInfoToRollout.name}?`;
        const percent = this.options.percent ?? (await (0, utils_2.promptForRolloutPercentAsync)({ promptMessage }));
        const rolloutBranchMapping = (0, branch_mapping_2.createRolloutBranchMapping)({
            defaultBranchId,
            rolloutBranchId: branchInfoToRollout.id,
            percent,
            runtimeVersion,
        });
        const channelObject = await this.getChannelObjectAsync(ctx, runtimeVersion);
        const defaultBranch = (0, utils_1.getUpdateBranch)(channelObject, defaultBranchId);
        const defaultUpdateGroup = defaultBranch.updateGroups[0];
        const rolloutInfo = (0, branch_mapping_2.getRolloutInfoFromBranchMapping)(rolloutBranchMapping);
        const rolledOutBranchUpdateGroup = await this.getLatestUpdateGroupOnBranchAsync(ctx, branchInfoToRollout, runtimeVersion);
        const rolledOutBranch = (0, ChannelQuery_1.composeUpdateBranchObject)(branchInfoToRollout, rolledOutBranchUpdateGroup ? [rolledOutBranchUpdateGroup] : []);
        const rollout = (0, branch_mapping_2.composeRollout)(rolloutInfo, defaultBranch, rolledOutBranch);
        (0, utils_2.displayRolloutDetails)(this.channelInfo.name, rollout);
        log_1.default.log((0, utils_2.formatBranchWithUpdateGroup)(defaultUpdateGroup, defaultBranch, 100 - rollout.percentRolledOut));
        log_1.default.addNewLineIfNone();
        log_1.default.log((0, utils_2.formatBranchWithUpdateGroup)(rolledOutBranchUpdateGroup, rolledOutBranch, rollout.percentRolledOut));
        log_1.default.addNewLineIfNone();
        const didConfirm = await this.confirmCreationAsync(ctx);
        if (!didConfirm) {
            throw new Error('Aborting...');
        }
        const newChannelInfo = await (0, edit_1.updateChannelBranchMappingAsync)(graphqlClient, {
            channelId: this.channelInfo.id,
            branchMapping: JSON.stringify(rolloutBranchMapping),
        });
        log_1.default.succeed('âœ… Successfully created rollout');
        return newChannelInfo;
    }
    async confirmCreationAsync(ctx) {
        const { nonInteractive } = ctx;
        if (nonInteractive) {
            return true;
        }
        return await (0, prompts_1.confirmAsync)({
            message: `Create rollout?`,
        });
    }
    async getChannelObjectAsync(ctx, runtimeVersion) {
        const { graphqlClient, app } = ctx;
        const { projectId } = app;
        return await ChannelQuery_1.ChannelQuery.viewUpdateChannelAsync(graphqlClient, {
            appId: projectId,
            channelName: this.channelInfo.name,
            filter: { runtimeVersions: [runtimeVersion] },
        });
    }
    async getLatestUpdateGroupOnBranchAsync(ctx, branchInfo, runtimeVersion) {
        const { graphqlClient, app } = ctx;
        const { projectId } = app;
        const updateGroups = await UpdateQuery_1.UpdateQuery.viewUpdateGroupsOnBranchAsync(graphqlClient, {
            appId: projectId,
            branchName: branchInfo.name,
            limit: 1,
            offset: 0,
            filter: {
                runtimeVersions: [runtimeVersion],
            },
        });
        (0, assert_1.default)(updateGroups.length < 2, `Expected at most one update group. Received: ${JSON.stringify(updateGroups)}`);
        return updateGroups[0] ?? null;
    }
    async selectRuntimeVersionAsync(ctx, branchToRollout, defaultBranchId) {
        const { graphqlClient, app } = ctx;
        const { projectId } = app;
        // we just want the branch name, not the update group
        const channelObjectRtvAgnostic = await ChannelQuery_1.ChannelQuery.viewUpdateChannelAsync(graphqlClient, {
            appId: projectId,
            channelName: this.channelInfo.name,
        });
        const defaultBranchRtvAgnostic = (0, utils_1.getUpdateBranch)(channelObjectRtvAgnostic, defaultBranchId);
        const selectSharedRuntimeAction = new SelectRuntime_1.SelectRuntime(branchToRollout, {
            anotherBranchToIntersectRuntimesBy: defaultBranchRtvAgnostic,
        });
        const sharedRuntime = await selectSharedRuntimeAction.runAsync(ctx);
        if (sharedRuntime) {
            return sharedRuntime;
        }
        return await this.selectRuntimeVersionFromAlternativeSourceAsync(ctx, branchToRollout, defaultBranchRtvAgnostic);
    }
    async selectRuntimeVersionFromAlternativeSourceAsync(ctx, branchToRollout, defaultBranch) {
        const { runtimeSource: selectedRuntimeSource } = await (0, prompts_1.promptAsync)({
            type: 'select',
            name: 'runtimeSource',
            message: `What would you like to do?`,
            choices: [
                {
                    value: 'DEFAULT_BRANCH_RUNTIME',
                    title: `Find a runtime supported on the ${defaultBranch.name} branch`,
                },
                {
                    value: 'ROLLED_OUT_BRANCH_RUNTIME',
                    title: `Find a runtime supported on the ${branchToRollout.name} branch`,
                },
                {
                    value: 'PROJECT_RUNTIME',
                    title: 'Use the runtime specified in your project config',
                },
            ],
        });
        if (selectedRuntimeSource === 'DEFAULT_BRANCH_RUNTIME') {
            const selectDefaultBranchRuntimeAction = new SelectRuntime_1.SelectRuntime(defaultBranch);
            const defaultBranchRuntime = await selectDefaultBranchRuntimeAction.runAsync(ctx);
            if (defaultBranchRuntime) {
                return defaultBranchRuntime;
            }
        }
        else if (selectedRuntimeSource === 'ROLLED_OUT_BRANCH_RUNTIME') {
            const selectBranchToRolloutRuntimeAction = new SelectRuntime_1.SelectRuntime(branchToRollout);
            const branchToRolloutRuntime = await selectBranchToRolloutRuntimeAction.runAsync(ctx);
            if (branchToRolloutRuntime) {
                return branchToRolloutRuntime;
            }
        }
        else if (selectedRuntimeSource === 'PROJECT_RUNTIME') {
            return await this.selectRuntimeVersionFromProjectConfigAsync(ctx);
        }
        else {
            throw new Error(`Unexpected runtime source: ${selectedRuntimeSource}`);
        }
        return await this.selectRuntimeVersionFromAlternativeSourceAsync(ctx, branchToRollout, defaultBranch);
    }
    async selectRuntimeVersionFromProjectConfigAsync(ctx) {
        const platforms = ['ios', 'android'];
        const workflows = await (0, workflow_1.resolveWorkflowPerPlatformAsync)(ctx.app.projectDir, ctx.vcsClient);
        const runtimes = (await Promise.all(platforms.map(platform => (0, resolveRuntimeVersionAsync_1.resolveRuntimeVersionAsync)({
            projectDir: ctx.app.projectDir,
            exp: ctx.app.exp,
            platform,
            workflow: workflows[platform],
            env: undefined,
        }))))
            .map(runtime => runtime?.runtimeVersion)
            .filter(filter_1.truthy);
        const dedupedRuntimes = [...new Set(runtimes)];
        if (dedupedRuntimes.length === 0) {
            throw new Error(`Your project config doesn't specify a runtime. Ensure your project is configured correctly for EAS Update by running \`eas update:configure\``);
        }
        else if (dedupedRuntimes.length === 1) {
            const runtime = dedupedRuntimes[0];
            log_1.default.log(`ðŸ”§ Your project config currently supports runtime ${runtime}`);
            return runtime;
        }
        const { runtime: selectedRuntime } = await (0, prompts_1.promptAsync)({
            type: 'select',
            name: 'runtime',
            message: `Select a runtime supported by your project config`,
            choices: runtimes.map((runtime, index) => ({
                title: `${runtime} ${index === 0 ? '[iOS runtime]' : '[Android runtime]'}`,
                value: runtime,
            })),
        });
        return selectedRuntime;
    }
    async selectBranchAsync(ctx, defaultBranchId) {
        const selectBranchAction = new SelectBranch_1.SelectBranch({
            printedType: 'branch to roll out',
            // we don't want to show the default branch as an option
            filterPredicate: (branchInfo) => branchInfo.id !== defaultBranchId,
        });
        const branchInfo = await selectBranchAction.runAsync(ctx);
        if (!branchInfo) {
            // We know the user has at least one branch, since we have `defaultBranchId`
            throw new Error(`You don't have a second branch to roll out. Create it with 'eas branch:create'`);
        }
        return branchInfo;
    }
    async resolveBranchNameAsync(ctx, branchName) {
        const { graphqlClient, app } = ctx;
        return await BranchQuery_1.BranchQuery.getBranchByNameAsync(graphqlClient, {
            appId: app.projectId,
            name: branchName,
        });
    }
}
exports.CreateRollout = CreateRollout;
