"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonInteractiveRollout = void 0;
const tslib_1 = require("tslib");
const CreateRollout_1 = require("./CreateRollout");
const EditRollout_1 = require("./EditRollout");
const EndRollout_1 = require("./EndRollout");
const ManageRollout_1 = require("./ManageRollout");
const RolloutMainMenu_1 = require("./RolloutMainMenu");
const ChannelQuery_1 = require("../../graphql/queries/ChannelQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const json_1 = require("../../utils/json");
const branch_mapping_1 = require("../branch-mapping");
const utils_1 = require("../utils");
/**
 * Control a rollout in non interactive mode.
 */
class NonInteractiveRollout {
    constructor(options) {
        this.options = options;
    }
    async runAsync(ctx) {
        const { channelName, action } = this.options;
        const { nonInteractive, app, graphqlClient } = ctx;
        if (!nonInteractive) {
            throw new Error(`This action is meant for non-interactive mode.`);
        }
        if (!channelName) {
            throw new Error(`The channel argument is required in non-interactive mode. Run eas channel:rollout [channel-name]`);
        }
        const channelInfo = await ChannelQuery_1.ChannelQuery.viewUpdateChannelAsync(graphqlClient, {
            appId: app.projectId,
            channelName,
        });
        const channelObject = await this.getChannelObjectAsync(ctx, {
            channelName,
            runtimeVersion: this.getRuntimeVersion(channelInfo),
        });
        if (!action) {
            throw new Error(`--action is required in non-interactive mode.`);
        }
        const updatedChannelInfo = await this.runActionAsync(ctx, action, channelObject);
        const updatedChannelObject = await this.getChannelObjectAsync(ctx, {
            channelName,
            runtimeVersion: this.getRuntimeVersion(updatedChannelInfo),
        });
        if (this.options.json) {
            const json = await this.getJsonAsync({
                originalChannelObject: channelObject,
                updatedChannelObject,
            });
            (0, json_1.printJsonOnlyOutput)(json);
        }
    }
    async runActionAsync(ctx, action, channelObject) {
        switch (action) {
            case RolloutMainMenu_1.MainMenuActions.CREATE_NEW:
                return await new CreateRollout_1.CreateRollout(channelObject, this.options).runAsync(ctx);
            case ManageRollout_1.ManageRolloutActions.EDIT:
                return await new EditRollout_1.EditRollout(channelObject, this.options).runAsync(ctx);
            case ManageRollout_1.ManageRolloutActions.END:
                return await new EndRollout_1.EndRollout(channelObject, this.options).runAsync(ctx);
            case ManageRollout_1.ManageRolloutActions.VIEW:
                return this.viewRollout(channelObject);
        }
    }
    viewRollout(channelObject) {
        if (!this.options.json) {
            (0, utils_1.printRollout)(channelObject);
            log_1.default.warn('For formatted output, add the --json flag to your command.');
        }
        return channelObject;
    }
    async getJsonAsync({ originalChannelObject, updatedChannelObject, }) {
        return {
            hasRollout: (0, branch_mapping_1.isRollout)(updatedChannelObject),
            ...((0, branch_mapping_1.isRollout)(originalChannelObject)
                ? { originalRolloutInfo: await this.getRolloutJsonAsync(originalChannelObject) }
                : {}),
            ...((0, branch_mapping_1.isRollout)(updatedChannelObject)
                ? { currentRolloutInfo: await this.getRolloutJsonAsync(updatedChannelObject) }
                : {}),
        };
    }
    async getRolloutJsonAsync(channelObject) {
        const rollout = (0, branch_mapping_1.getRollout)(channelObject);
        return {
            defaultBranch: rollout.defaultBranch,
            rolledOutBranch: rollout.rolledOutBranch,
            percentRolledOut: rollout.percentRolledOut,
            runtimeVersion: this.getRuntimeVersion(channelObject) ?? undefined,
            updatedAt: channelObject.updatedAt,
        };
    }
    getRuntimeVersion(channelInfo) {
        if ((0, branch_mapping_1.isRollout)(channelInfo)) {
            const updatedRolloutInfo = (0, branch_mapping_1.getRolloutInfo)(channelInfo);
            if ((0, branch_mapping_1.isConstrainedRolloutInfo)(updatedRolloutInfo)) {
                return updatedRolloutInfo.runtimeVersion;
            }
        }
        return undefined;
    }
    async getChannelObjectAsync(ctx, { channelName, runtimeVersion }) {
        const { graphqlClient, app } = ctx;
        const { projectId } = app;
        return await ChannelQuery_1.ChannelQuery.viewUpdateChannelAsync(graphqlClient, {
            appId: projectId,
            channelName,
            ...(runtimeVersion ? { filter: { runtimeVersions: [runtimeVersion] } } : {}),
        });
    }
}
exports.NonInteractiveRollout = NonInteractiveRollout;
