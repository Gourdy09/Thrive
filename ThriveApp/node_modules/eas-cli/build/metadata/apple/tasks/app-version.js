"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppVersionTask = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const log_1 = tslib_1.__importDefault(require("../../../log"));
const log_2 = require("../../utils/log");
const retry_1 = require("../../utils/retry");
const task_1 = require("../task");
class AppVersionTask extends task_1.AppleTask {
    constructor(options = {}) {
        super();
        this.name = () => (this.options.editLive ? 'live app version' : 'editable app version');
        this.options = {
            platform: options.platform ?? apple_utils_1.Platform.IOS,
            editLive: options.editLive ?? false,
            version: options.version ?? null,
        };
    }
    async prepareAsync({ context }) {
        const { version, versionIsFirst, versionIsLive } = await resolveVersionAsync(context.app, this.options);
        (0, assert_1.default)(version, 'Could not resolve a live or editable app version');
        context.version = version;
        context.versionIsFirst = versionIsFirst;
        context.versionIsLive = versionIsLive;
        context.versionLocales = await version.getLocalizationsAsync();
        context.versionPhasedRelease = await version.getPhasedReleaseAsync();
    }
    async downloadAsync({ config, context }) {
        (0, assert_1.default)(context.version, `App version not initialized, can't download version`);
        config.setVersion(context.version.attributes);
        config.setVersionReleaseType(context.version.attributes);
        config.setVersionReleasePhased(context.versionPhasedRelease?.attributes);
        for (const locale of context.versionLocales) {
            config.setVersionLocale(locale.attributes);
        }
    }
    async uploadAsync({ config, context }) {
        const version = config.getVersion();
        if (!context.version && version?.versionString) {
            context.version = await (0, log_2.logAsync)(() => {
                return context.app.createVersionAsync({
                    versionString: version.versionString,
                    platform: this.options.platform,
                });
            }, {
                pending: `Creating new version ${chalk_1.default.bold(version.versionString)}...`,
                success: `Created new version ${chalk_1.default.bold(version.versionString)}`,
                failure: `Failed creating new version ${chalk_1.default.bold(version.versionString)}`,
            });
        }
        (0, assert_1.default)(context.version, `App version not initialized, can't update version`);
        const { versionString } = context.version.attributes;
        const release = config.getVersionReleaseType();
        if (!version && !release) {
            log_1.default.log((0, chalk_1.default) `{dim - Skipped version and release update, not configured}`);
        }
        else {
            const description = [version && 'version', release && 'release']
                .filter(Boolean)
                .join(' and ');
            context.version = await (0, log_2.logAsync)(() => context.version.updateAsync({ ...version, ...release }), {
                pending: `Updating ${description} info for ${chalk_1.default.bold(versionString)}...`,
                success: `Updated ${description} info for ${chalk_1.default.bold(versionString)}`,
                failure: `Failed updating ${description} info for ${chalk_1.default.bold(versionString)}`,
            });
        }
        const phasedRelease = config.getVersionReleasePhased();
        if (!phasedRelease && shouldDeletePhasedRelease(context.versionPhasedRelease)) {
            // if phased release was enabled, but now disabled, we need to remove it
            await (0, log_2.logAsync)(() => context.versionPhasedRelease.deleteAsync(), {
                pending: `Disabling phased release for ${chalk_1.default.bold(versionString)}...`,
                success: `Disabled phased release for ${chalk_1.default.bold(versionString)}`,
                failure: `Failed disabling phased release for ${chalk_1.default.bold(versionString)}`,
            });
            context.versionPhasedRelease = null;
        }
        else if (phasedRelease && !context.versionPhasedRelease) {
            // if phased release was not yet set, but now enabled, we need to create it
            context.versionPhasedRelease = await (0, log_2.logAsync)(() => context.version.createPhasedReleaseAsync({ state: phasedRelease.phasedReleaseState }), {
                pending: `Enabling phased release for ${chalk_1.default.bold(versionString)}...`,
                success: `Enabled phased release for ${chalk_1.default.bold(versionString)}`,
                failure: `Failed enabling phased release for ${chalk_1.default.bold(versionString)}`,
            });
        }
        const locales = config.getLocales();
        if (locales.length <= 0) {
            log_1.default.log((0, chalk_1.default) `{dim - Skipped localized version update, no locales configured}`);
        }
        else {
            for (const locale of locales) {
                const attributes = config.getVersionLocale(locale, context);
                if (!attributes) {
                    continue;
                }
                const oldModel = context.versionLocales.find(model => model.attributes.locale === locale);
                await (0, log_2.logAsync)(async () => {
                    return oldModel
                        ? await oldModel.updateAsync(attributes)
                        : await context.version.createLocalizationAsync({ ...attributes, locale });
                }, {
                    pending: `${oldModel ? 'Updating' : 'Creating'} localized version for ${chalk_1.default.bold(locale)}...`,
                    success: `${oldModel ? 'Updated' : 'Created'} localized version for ${chalk_1.default.bold(locale)}`,
                    failure: `Failed ${oldModel ? 'updating' : 'creating'} localized version for ${chalk_1.default.bold(locale)}`,
                });
            }
            context.versionLocales = await context.version.getLocalizationsAsync();
        }
    }
}
exports.AppVersionTask = AppVersionTask;
/**
 * Resolve the AppStoreVersion instance, either from the store config, live, or editable version.
 * This also checks if this is the first version, which disallow release notes.
 */
async function resolveVersionAsync(app, { editLive, platform, version: versionString }) {
    let version = null;
    let versionIsLive = false;
    if (versionString) {
        version = await findEditAppStoreVersionAsync(app, { platform, version: versionString });
        if (!version) {
            version = await createOrUpdateEditAppStoreVersionAsync(app, {
                platform,
                version: versionString,
            });
        }
        versionIsLive = version?.attributes.appStoreState === apple_utils_1.AppStoreState.READY_FOR_SALE;
    }
    if (!version && editLive) {
        version = await app.getLiveAppStoreVersionAsync({ platform });
        versionIsLive = !!version;
    }
    if (!version) {
        version = await (0, retry_1.retryIfNullAsync)(() => app.getEditAppStoreVersionAsync({ platform }));
    }
    const versions = await app.getAppStoreVersionsAsync({
        query: { limit: 2, filter: { platform } },
    });
    return {
        version,
        versionIsLive,
        versionIsFirst: versions.length === 1,
    };
}
/**
 * Determine if we can, and should, delete the phased release instance.
 * This returns true if the instance exist, and has one of the states below:
 *   - PhasedReleaseState.INACTIVE
 *   - PhasedReleaseState.ACTIVE
 *   - PhasedReleaseState.PAUSED
 */
function shouldDeletePhasedRelease(phasedRelease) {
    if (!phasedRelease ||
        phasedRelease.attributes.phasedReleaseState === apple_utils_1.PhasedReleaseState.COMPLETE) {
        return false;
    }
    return true;
}
/*
 * Search for editable app store versions that matches the `versionString` option.
 * When nothing is found, it will return `null`, and a new version should be created.
 */
async function findEditAppStoreVersionAsync(app, options) {
    if (options.version) {
        const versions = await app.getAppStoreVersionsAsync({
            query: {
                limit: 200,
                filter: {
                    platform: options.platform,
                    appStoreState: [
                        apple_utils_1.AppStoreState.PREPARE_FOR_SUBMISSION,
                        apple_utils_1.AppStoreState.DEVELOPER_REJECTED,
                        apple_utils_1.AppStoreState.REJECTED,
                        apple_utils_1.AppStoreState.METADATA_REJECTED,
                        apple_utils_1.AppStoreState.WAITING_FOR_REVIEW,
                        apple_utils_1.AppStoreState.INVALID_BINARY,
                    ].join(','),
                },
            },
        });
        const version = versions.find(model => model.attributes.versionString === options.version);
        if (version) {
            return version;
        }
    }
    return null;
}
/**
 * Check if we can reuse an existing editable app version that has not been published yet.
 * If not, it creates a new version based on the version string.
 */
async function createOrUpdateEditAppStoreVersionAsync(app, options) {
    const version = await app.getEditAppStoreVersionAsync({ platform: options.platform });
    if (version) {
        return await version.updateAsync({ versionString: options.version });
    }
    return await app.createVersionAsync({
        versionString: options.version,
        platform: options.platform,
    });
}
