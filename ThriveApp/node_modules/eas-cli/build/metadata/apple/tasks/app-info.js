"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppInfoTask = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const log_1 = tslib_1.__importDefault(require("../../../log"));
const log_2 = require("../../utils/log");
const retry_1 = require("../../utils/retry");
const task_1 = require("../task");
class AppInfoTask extends task_1.AppleTask {
    constructor() {
        super(...arguments);
        this.name = () => 'app information';
    }
    async prepareAsync({ context }) {
        const info = await (0, retry_1.retryIfNullAsync)(() => context.app.getEditAppInfoAsync());
        (0, assert_1.default)(info, 'Could not resolve the editable app info to update');
        context.info = info;
        context.infoLocales = await info.getLocalizationsAsync();
    }
    async downloadAsync({ config, context }) {
        (0, assert_1.default)(context.info, `App info not initialized, can't download info`);
        config.setCategories(context.info.attributes);
        for (const locale of context.infoLocales) {
            config.setInfoLocale(locale.attributes);
        }
    }
    async uploadAsync({ config, context }) {
        (0, assert_1.default)(context.info, `App info not initialized, can't update info`);
        const categories = config.getCategories();
        if (!categories) {
            log_1.default.log((0, chalk_1.default) `{dim - Skipped app category update, not configured}`);
        }
        else {
            context.info = await (0, log_2.logAsync)(() => context.info.updateCategoriesAsync(categories), {
                pending: 'Updating app categories...',
                success: 'Updated app categories',
                failure: 'Failed updating app categories',
            });
        }
        const locales = config.getLocales();
        if (locales.length <= 0) {
            log_1.default.log((0, chalk_1.default) `{dim - Skipped localized info update, no locales configured}`);
        }
        else {
            // BUG: new issue introduced in ASC 1.8.0, when creating version locales, info locales are also generated
            context.infoLocales = await (0, log_2.logAsync)(() => context.info.getLocalizationsAsync(), {
                pending: 'Reloading localized info...',
                success: 'Reloaded localized info',
                failure: 'Failed reloading localized info',
            });
            for (const locale of locales) {
                const attributes = config.getInfoLocale(locale);
                if (!attributes) {
                    continue;
                }
                const model = context.infoLocales.find(model => model.attributes.locale === locale);
                await (0, log_2.logAsync)(async () => {
                    return model
                        ? await model.updateAsync(attributes)
                        : await context.info.createLocalizationAsync({ ...attributes, locale });
                }, {
                    pending: `${model ? 'Updating' : 'Creating'} localized info for ${chalk_1.default.bold(locale)}...`,
                    success: `${model ? 'Updated' : 'Created'} localized info for ${chalk_1.default.bold(locale)}`,
                    failure: `Failed ${model ? 'updating' : 'creating'} localized info for ${chalk_1.default.bold(locale)}`,
                });
            }
            context.infoLocales = await context.info.getLocalizationsAsync();
        }
    }
}
exports.AppInfoTask = AppInfoTask;
