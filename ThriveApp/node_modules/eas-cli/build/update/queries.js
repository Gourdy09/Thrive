"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectUpdateGroupOnBranchAsync = exports.listAndRenderUpdateGroupsOnBranchAsync = exports.listAndRenderUpdateGroupsOnAppAsync = exports.UPDATE_GROUPS_LIMIT = exports.UPDATES_LIMIT = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const utils_1 = require("./utils");
const UpdateQuery_1 = require("../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importDefault(require("../log"));
const formatFields_1 = tslib_1.__importDefault(require("../utils/formatFields"));
const json_1 = require("../utils/json");
const queries_1 = require("../utils/queries");
exports.UPDATES_LIMIT = 50;
exports.UPDATE_GROUPS_LIMIT = 25;
async function listAndRenderUpdateGroupsOnAppAsync(graphqlClient, { projectId, paginatedQueryOptions, }) {
    if (paginatedQueryOptions.nonInteractive) {
        const updateGroups = await queryUpdateGroupsOnAppAsync(graphqlClient, {
            limit: paginatedQueryOptions.limit ?? exports.UPDATE_GROUPS_LIMIT,
            offset: paginatedQueryOptions.offset,
            appId: projectId,
        });
        renderUpdateGroupsOnApp({ updateGroups, paginatedQueryOptions });
    }
    else {
        await (0, queries_1.paginatedQueryWithConfirmPromptAsync)({
            limit: paginatedQueryOptions.limit ?? exports.UPDATE_GROUPS_LIMIT,
            offset: paginatedQueryOptions.offset,
            queryToPerform: (limit, offset) => queryUpdateGroupsOnAppAsync(graphqlClient, { limit, offset, appId: projectId }),
            promptOptions: {
                title: 'Load more update groups?',
                renderListItems: updateGroups => {
                    renderUpdateGroupsOnApp({ updateGroups, paginatedQueryOptions });
                },
            },
        });
    }
}
exports.listAndRenderUpdateGroupsOnAppAsync = listAndRenderUpdateGroupsOnAppAsync;
async function listAndRenderUpdateGroupsOnBranchAsync(graphqlClient, { projectId, branchName, paginatedQueryOptions, }) {
    if (paginatedQueryOptions.nonInteractive) {
        const updateGroups = await queryUpdateGroupsOnBranchAsync(graphqlClient, {
            limit: paginatedQueryOptions.limit ?? exports.UPDATE_GROUPS_LIMIT,
            offset: paginatedQueryOptions.offset,
            appId: projectId,
            branchName,
        });
        renderUpdateGroupsOnBranch({ updateGroups, branchName, paginatedQueryOptions });
    }
    else {
        await (0, queries_1.paginatedQueryWithConfirmPromptAsync)({
            limit: paginatedQueryOptions.limit ?? exports.UPDATE_GROUPS_LIMIT,
            offset: paginatedQueryOptions.offset,
            queryToPerform: (limit, offset) => queryUpdateGroupsOnBranchAsync(graphqlClient, {
                limit,
                offset,
                appId: projectId,
                branchName,
            }),
            promptOptions: {
                title: 'Load more update groups?',
                renderListItems: updateGroups => {
                    renderUpdateGroupsOnBranch({ updateGroups, branchName, paginatedQueryOptions });
                },
            },
        });
    }
}
exports.listAndRenderUpdateGroupsOnBranchAsync = listAndRenderUpdateGroupsOnBranchAsync;
async function selectUpdateGroupOnBranchAsync(graphqlClient, { projectId, branchName, paginatedQueryOptions, }) {
    if (paginatedQueryOptions.nonInteractive) {
        throw new Error('Unable to select an update in non-interactive mode.');
    }
    const updateGroup = await (0, queries_1.paginatedQueryWithSelectPromptAsync)({
        limit: paginatedQueryOptions.limit ?? exports.UPDATE_GROUPS_LIMIT,
        offset: paginatedQueryOptions.offset,
        queryToPerform: (limit, offset) => queryUpdateGroupsOnBranchAsync(graphqlClient, {
            appId: projectId,
            branchName,
            limit,
            offset,
        }),
        promptOptions: {
            title: 'Load more update groups?',
            makePartialChoiceObject: updateGroup => ({
                title: (0, utils_1.formatUpdateTitle)(updateGroup[0]),
            }),
            getIdentifierForQueryItem: updateGroup => updateGroup[0].group,
        },
    });
    if (!updateGroup || updateGroup.length === 0) {
        throw new Error(`Could not find any branches for project "${projectId}"`);
    }
    return updateGroup;
}
exports.selectUpdateGroupOnBranchAsync = selectUpdateGroupOnBranchAsync;
async function queryUpdateGroupsOnBranchAsync(graphqlClient, args) {
    return await UpdateQuery_1.UpdateQuery.viewUpdateGroupsOnBranchAsync(graphqlClient, args);
}
async function queryUpdateGroupsOnAppAsync(graphqlClient, args) {
    return await UpdateQuery_1.UpdateQuery.viewUpdateGroupsOnAppAsync(graphqlClient, args);
}
function renderUpdateGroupsOnBranch({ branchName, updateGroups, paginatedQueryOptions: { json }, }) {
    // Ensure all updates are from the same branch
    const branchNames = updateGroups.flatMap(updateGroup => updateGroup.map(update => update.branch.name));
    (0, assert_1.default)(branchNames.every(name => name === branchName), 'Each update must belong to the same branch.');
    const updateGroupDescriptions = (0, utils_1.getUpdateGroupDescriptionsWithBranch)(updateGroups);
    const branch = {
        name: branchName,
        id: updateGroups[0]?.[0].branch.id ?? 'N/A',
    };
    if (json) {
        (0, json_1.printJsonOnlyOutput)({ ...branch, currentPage: updateGroupDescriptions });
        return;
    }
    log_1.default.addNewLineIfNone();
    log_1.default.log(chalk_1.default.bold('Branch:'));
    log_1.default.log((0, formatFields_1.default)([
        { label: 'Name', value: branch.name },
        { label: 'ID', value: branch.id },
    ]));
    log_1.default.newLine();
    log_1.default.log(chalk_1.default.bold('Recent update groups:'));
    log_1.default.newLine();
    log_1.default.log(updateGroupDescriptions
        .map(description => (0, utils_1.formatUpdateGroup)(description))
        .join(`\n\n${chalk_1.default.dim('———')}\n\n`));
}
function renderUpdateGroupsOnApp({ updateGroups, paginatedQueryOptions: { json }, }) {
    const updateGroupDescriptions = (0, utils_1.getUpdateGroupDescriptionsWithBranch)(updateGroups);
    if (json) {
        (0, json_1.printJsonOnlyOutput)({ currentPage: updateGroupDescriptions });
    }
    log_1.default.addNewLineIfNone();
    log_1.default.log(chalk_1.default.bold('Recent update groups:'));
    log_1.default.newLine();
    log_1.default.log(updateGroupDescriptions
        .map(({ branch, ...update }) => (0, utils_1.formatBranch)({
        branch,
        update,
    }))
        .join(`\n\n${chalk_1.default.dim('———')}\n\n`));
}
