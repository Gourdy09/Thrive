"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.packFilesIterableAsync = exports.listAssetMapFilesAsync = exports.listWorkerFilesAsync = exports.createAssetMapAsync = exports.createManifestAsync = void 0;
const tslib_1 = require("tslib");
const env_1 = require("@expo/env");
const minizlib_1 = require("minizlib");
const node_crypto_1 = require("node:crypto");
const node_fs_1 = tslib_1.__importStar(require("node:fs"));
const node_os_1 = tslib_1.__importDefault(require("node:os"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const promises_1 = require("node:stream/promises");
const tar_stream_1 = require("tar-stream");
const EnvironmentVariablesQuery_1 = require("../graphql/queries/EnvironmentVariablesQuery");
/** Returns whether a file or folder is ignored */
function isIgnoredName(name) {
    switch (name) {
        // macOS system files
        case '.DS_Store':
        case '.AppleDouble':
        case '.Trashes':
        case '__MACOSX':
        case '.LSOverride':
            return true;
        default:
            // Backup file name convention
            return name.endsWith('~');
    }
}
/** Creates a temporary file write path */
async function createTempWritePathAsync() {
    const basename = node_path_1.default.basename(__filename, node_path_1.default.extname(__filename));
    const tmpdir = await node_fs_1.default.promises.realpath(node_os_1.default.tmpdir());
    const random = (0, node_crypto_1.randomBytes)(4).toString('hex');
    return node_path_1.default.resolve(tmpdir, `tmp-${basename}-${process.pid}-${random}`);
}
/** Computes a SHA512 hash for a file */
async function computeSha512HashAsync(filePath, options) {
    const hash = (0, node_crypto_1.createHash)('sha512', { encoding: 'hex', ...options });
    await (0, promises_1.pipeline)(node_fs_1.default.createReadStream(filePath), hash);
    return `${hash.read()}`;
}
/** Lists plain files in base path recursively and outputs normalized paths */
function listFilesRecursively(basePath) {
    async function* recurseAsync(parentPath) {
        const target = parentPath ? node_path_1.default.resolve(basePath, parentPath) : basePath;
        const entries = await node_fs_1.default.promises.readdir(target, { withFileTypes: true });
        for (const dirent of entries) {
            const normalizedPath = parentPath ? `${parentPath}/${dirent.name}` : dirent.name;
            if (isIgnoredName(dirent.name)) {
                continue;
            }
            else if (dirent.isFile()) {
                yield {
                    normalizedPath,
                    path: node_path_1.default.resolve(target, dirent.name),
                };
            }
            else if (dirent.isDirectory()) {
                yield* recurseAsync(normalizedPath);
            }
        }
    }
    return recurseAsync();
}
/** Creates an asset map of a given target path */
async function createAssetMapAsync(assetPath, options) {
    const map = Object.create(null);
    if (assetPath) {
        for await (const file of listFilesRecursively(assetPath)) {
            map[file.normalizedPath] = await computeSha512HashAsync(file.path, options?.hashOptions);
        }
    }
    return map;
}
exports.createAssetMapAsync = createAssetMapAsync;
/** Creates a manifest configuration sent up for deployment */
async function createManifestAsync(params, graphqlClient) {
    let env;
    if (params.environment) {
        env = Object.fromEntries((await EnvironmentVariablesQuery_1.EnvironmentVariablesQuery.byAppIdWithSensitiveAsync(graphqlClient, {
            appId: params.projectId,
            environment: params.environment,
        })).map(variable => [variable.name, variable.value ?? undefined]));
    }
    else {
        // NOTE: This is required for the .env resolution
        process.env.NODE_ENV = 'production';
        env = (0, env_1.get)(params.projectDir).env;
    }
    return { env };
}
exports.createManifestAsync = createManifestAsync;
/** Reads worker files while normalizing sourcemaps and providing normalized paths */
async function* listWorkerFilesAsync(workerPath) {
    for await (const file of listFilesRecursively(workerPath)) {
        yield {
            normalizedPath: file.normalizedPath,
            path: file.path,
            data: await node_fs_1.default.promises.readFile(file.path),
        };
    }
}
exports.listWorkerFilesAsync = listWorkerFilesAsync;
/** Reads files of an asset maps and enumerates normalized paths and data */
async function* listAssetMapFilesAsync(assetPath, assetMap) {
    for (const normalizedPath in assetMap) {
        const filePath = node_path_1.default.resolve(assetPath, normalizedPath.split('/').join(node_path_1.default.sep));
        const data = await node_fs_1.default.promises.readFile(filePath);
        yield {
            normalizedPath,
            path: filePath,
            data,
        };
    }
}
exports.listAssetMapFilesAsync = listAssetMapFilesAsync;
/** Packs file entries into a tar.gz file (path to tgz returned) */
async function packFilesIterableAsync(iterable, options) {
    const writePath = `${await createTempWritePathAsync()}.tar.gz`;
    const write = (0, node_fs_1.createWriteStream)(writePath);
    const gzip = new minizlib_1.Gzip({ portable: true, ...options });
    const tar = (0, tar_stream_1.pack)();
    const writeTask$ = (0, promises_1.pipeline)(tar, gzip, write);
    for await (const file of iterable) {
        tar.entry({ name: file[0], type: 'file' }, file[1]);
    }
    tar.finalize();
    await writeTask$;
    return writePath;
}
exports.packFilesIterableAsync = packFilesIterableAsync;
