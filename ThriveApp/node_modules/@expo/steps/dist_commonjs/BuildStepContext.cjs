"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildStepContext = exports.BuildStepGlobalContext = void 0;
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const BuildStep_js_1 = require("./BuildStep.cjs");
const template_js_1 = require("./utils/template.cjs");
const errors_js_1 = require("./errors.cjs");
class BuildStepGlobalContext {
    constructor(provider, skipCleanup) {
        this.provider = provider;
        this.skipCleanup = skipCleanup;
        this.didCheckOut = false;
        this.stepById = {};
        this.stepsInternalBuildDirectory = path_1.default.join(os_1.default.tmpdir(), 'eas-build', (0, uuid_1.v4)());
        this.runtimePlatform = provider.runtimePlatform;
        this.baseLogger = provider.logger;
    }
    get projectSourceDirectory() {
        return this.provider.projectSourceDirectory;
    }
    get projectTargetDirectory() {
        return this.provider.projectTargetDirectory;
    }
    get defaultWorkingDirectory() {
        return this.didCheckOut ? this.provider.defaultWorkingDirectory : this.projectTargetDirectory;
    }
    get buildLogsDirectory() {
        return this.provider.buildLogsDirectory;
    }
    get env() {
        return this.provider.env;
    }
    get staticContext() {
        return this.provider.staticContext();
    }
    updateEnv(updatedEnv) {
        this.provider.updateEnv(updatedEnv);
    }
    registerStep(step) {
        this.stepById[step.id] = step;
    }
    getStepOutputValue(path) {
        const { stepId, outputId } = (0, template_js_1.parseOutputPath)(path);
        if (!(stepId in this.stepById)) {
            throw new errors_js_1.BuildStepRuntimeError(`Step "${stepId}" does not exist.`);
        }
        return this.stepById[stepId].getOutputValueByName(outputId);
    }
    interpolate(value) {
        return (0, template_js_1.interpolateWithGlobalContext)(value, (path) => {
            var _a, _b;
            return ((_b = (_a = (0, template_js_1.getObjectValueForInterpolation)(path, {
                eas: {
                    runtimePlatform: this.runtimePlatform,
                    ...this.staticContext,
                },
            })) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '');
        });
    }
    stepCtx(options) {
        return new BuildStepContext(this, options);
    }
    markAsCheckedOut(logger) {
        this.didCheckOut = true;
        logger.info(`Changing default working directory to ${this.defaultWorkingDirectory} (was ${this.projectTargetDirectory})`);
    }
    wasCheckedOut() {
        return this.didCheckOut;
    }
    serialize() {
        return {
            stepsInternalBuildDirectory: this.stepsInternalBuildDirectory,
            stepById: Object.fromEntries(Object.entries(this.stepById).map(([id, step]) => [id, step.serialize()])),
            provider: {
                projectSourceDirectory: this.provider.projectSourceDirectory,
                projectTargetDirectory: this.provider.projectTargetDirectory,
                defaultWorkingDirectory: this.provider.defaultWorkingDirectory,
                buildLogsDirectory: this.provider.buildLogsDirectory,
                runtimePlatform: this.provider.runtimePlatform,
                staticContext: this.provider.staticContext(),
                env: this.provider.env,
            },
            skipCleanup: this.skipCleanup,
        };
    }
    static deserialize(serialized, logger) {
        const deserializedProvider = {
            projectSourceDirectory: serialized.provider.projectSourceDirectory,
            projectTargetDirectory: serialized.provider.projectTargetDirectory,
            defaultWorkingDirectory: serialized.provider.defaultWorkingDirectory,
            buildLogsDirectory: serialized.provider.buildLogsDirectory,
            runtimePlatform: serialized.provider.runtimePlatform,
            logger,
            staticContext: () => serialized.provider.staticContext,
            env: serialized.provider.env,
            updateEnv: () => { },
        };
        const ctx = new BuildStepGlobalContext(deserializedProvider, serialized.skipCleanup);
        for (const [id, stepOutputAccessor] of Object.entries(serialized.stepById)) {
            ctx.stepById[id] = BuildStep_js_1.BuildStepOutputAccessor.deserialize(stepOutputAccessor);
        }
        ctx.stepsInternalBuildDirectory = serialized.stepsInternalBuildDirectory;
        return ctx;
    }
}
exports.BuildStepGlobalContext = BuildStepGlobalContext;
class BuildStepContext {
    constructor(ctx, { logger, relativeWorkingDirectory, }) {
        this.ctx = ctx;
        this.logger = logger !== null && logger !== void 0 ? logger : ctx.baseLogger;
        this.relativeWorkingDirectory = relativeWorkingDirectory;
    }
    get global() {
        return this.ctx;
    }
    get workingDirectory() {
        return this.relativeWorkingDirectory
            ? path_1.default.resolve(this.ctx.defaultWorkingDirectory, this.relativeWorkingDirectory)
            : this.ctx.defaultWorkingDirectory;
    }
    serialize() {
        return {
            relativeWorkingDirectory: this.relativeWorkingDirectory,
            global: this.ctx.serialize(),
        };
    }
    static deserialize(serialized, logger) {
        const deserializedGlobal = BuildStepGlobalContext.deserialize(serialized.global, logger);
        return new BuildStepContext(deserializedGlobal, {
            logger,
            relativeWorkingDirectory: serialized.relativeWorkingDirectory,
        });
    }
}
exports.BuildStepContext = BuildStepContext;
//# sourceMappingURL=BuildStepContext.js.map