{"version":3,"file":"StepsConfigParser.js","sourceRoot":"","sources":["../src/StepsConfigParser.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from 'node:assert';\n\nimport {\n  FunctionStep,\n  isStepFunctionStep,\n  isStepShellStep,\n  ShellStep,\n  Step,\n  validateSteps,\n} from '@expo/eas-build-job';\n\nimport { BuildFunction, BuildFunctionById } from './BuildFunction.js';\nimport {\n  BuildFunctionGroup,\n  BuildFunctionGroupById,\n  createBuildFunctionGroupByIdMapping,\n} from './BuildFunctionGroup.js';\nimport { BuildStepGlobalContext } from './BuildStepContext.js';\nimport { BuildStep } from './BuildStep.js';\nimport { AbstractConfigParser } from './AbstractConfigParser.js';\nimport { BuildConfigError } from './errors.js';\nimport { BuildStepOutput } from './BuildStepOutput.js';\n\nexport class StepsConfigParser extends AbstractConfigParser {\n  private readonly steps: Step[];\n\n  constructor(\n    ctx: BuildStepGlobalContext,\n    {\n      steps,\n      externalFunctions,\n      externalFunctionGroups,\n    }: {\n      steps: Step[];\n      externalFunctions?: BuildFunction[];\n      externalFunctionGroups?: BuildFunctionGroup[];\n    }\n  ) {\n    super(ctx, {\n      externalFunctions,\n      externalFunctionGroups,\n    });\n\n    this.steps = steps;\n  }\n\n  protected async parseConfigToBuildStepsAndBuildFunctionByIdMappingAsync(): Promise<{\n    buildSteps: BuildStep[];\n    buildFunctionById: BuildFunctionById;\n  }> {\n    const validatedSteps = validateSteps(this.steps);\n    StepsConfigParser.validateAllFunctionsExist(validatedSteps, {\n      externalFunctionIds: this.getExternalFunctionFullIds(),\n      externalFunctionGroupIds: this.getExternalFunctionGroupFullIds(),\n    });\n\n    const buildFunctionById = this.createBuildFunctionByIdMappingForExternalFunctions();\n    const buildFunctionGroupById = createBuildFunctionGroupByIdMapping(\n      this.externalFunctionGroups ?? []\n    );\n\n    const buildSteps: BuildStep[] = [];\n    for (const stepConfig of validatedSteps) {\n      buildSteps.push(\n        ...this.createBuildStepsFromStepConfig(stepConfig, {\n          buildFunctionById,\n          buildFunctionGroupById,\n        })\n      );\n    }\n\n    return {\n      buildSteps,\n      buildFunctionById,\n    };\n  }\n\n  private createBuildFunctionByIdMappingForExternalFunctions(): BuildFunctionById {\n    const result: BuildFunctionById = {};\n\n    if (this.externalFunctions === undefined) {\n      return result;\n    }\n\n    for (const buildFunction of this.externalFunctions) {\n      const fullId = buildFunction.getFullId();\n      result[fullId] = buildFunction;\n    }\n    return result;\n  }\n\n  private createBuildStepsFromStepConfig(\n    stepConfig: Step,\n    {\n      buildFunctionById,\n      buildFunctionGroupById,\n    }: {\n      buildFunctionById: BuildFunctionById;\n      buildFunctionGroupById: BuildFunctionGroupById;\n    }\n  ): BuildStep[] {\n    if (isStepShellStep(stepConfig)) {\n      return [this.createBuildStepFromShellStepConfig(stepConfig)];\n    } else if (isStepFunctionStep(stepConfig)) {\n      return this.createBuildStepsFromFunctionStepConfig(stepConfig, {\n        buildFunctionById,\n        buildFunctionGroupById,\n      });\n    } else {\n      throw new BuildConfigError(\n        'Invalid job step configuration detected. Step must be shell or function step'\n      );\n    }\n  }\n\n  private createBuildStepFromShellStepConfig(step: ShellStep): BuildStep {\n    const id = BuildStep.getNewId(step.id);\n    const displayName = BuildStep.getDisplayName({ id, name: step.name, command: step.run });\n    const outputs =\n      step.outputs && this.createBuildStepOutputsFromDefinition(step.outputs, displayName);\n    return new BuildStep(this.ctx, {\n      id,\n      outputs,\n      name: step.name,\n      displayName,\n      workingDirectory: step.working_directory,\n      shell: step.shell,\n      command: step.run,\n      env: step.env,\n      ifCondition: step.if,\n    });\n  }\n\n  private createBuildStepsFromFunctionStepConfig(\n    step: FunctionStep,\n    {\n      buildFunctionById,\n      buildFunctionGroupById,\n    }: {\n      buildFunctionById: BuildFunctionById;\n      buildFunctionGroupById: BuildFunctionGroupById;\n    }\n  ): BuildStep[] {\n    const functionId = step.uses;\n    const maybeFunctionGroup = buildFunctionGroupById[functionId];\n    if (maybeFunctionGroup) {\n      // TODO: allow to set id, name, working_directory, shell, env and if for function groups\n      return maybeFunctionGroup.createBuildStepsFromFunctionGroupCall(this.ctx, {\n        callInputs: step.with,\n      });\n    }\n\n    const buildFunction = buildFunctionById[functionId];\n    assert(buildFunction, 'function ID must be ID of function or function group');\n\n    return [\n      buildFunction.createBuildStepFromFunctionCall(this.ctx, {\n        id: step.id,\n        name: step.name,\n        callInputs: step.with,\n        workingDirectory: step.working_directory,\n        shell: step.shell,\n        env: step.env,\n        ifCondition: step.if,\n      }),\n    ];\n  }\n\n  private createBuildStepOutputsFromDefinition(\n    stepOutputs: Required<ShellStep>['outputs'],\n    stepDisplayName: string\n  ): BuildStepOutput[] {\n    return stepOutputs.map(\n      (entry) =>\n        new BuildStepOutput(this.ctx, {\n          id: entry.name,\n          stepDisplayName,\n          required: entry.required ?? true,\n        })\n    );\n  }\n\n  private static validateAllFunctionsExist(\n    steps: Step[],\n    {\n      externalFunctionIds,\n      externalFunctionGroupIds,\n    }: {\n      externalFunctionIds: string[];\n      externalFunctionGroupIds: string[];\n    }\n  ): void {\n    const calledFunctionsOrFunctionGroupsSet = new Set<string>();\n    for (const step of steps) {\n      if (step.uses) {\n        calledFunctionsOrFunctionGroupsSet.add(step.uses);\n      }\n    }\n    const calledFunctionsOrFunctionGroup = Array.from(calledFunctionsOrFunctionGroupsSet);\n    const externalFunctionIdsSet = new Set(externalFunctionIds);\n    const externalFunctionGroupsIdsSet = new Set(externalFunctionGroupIds);\n    const nonExistentFunctionsOrFunctionGroups = calledFunctionsOrFunctionGroup.filter(\n      (calledFunctionOrFunctionGroup) => {\n        return (\n          !externalFunctionIdsSet.has(calledFunctionOrFunctionGroup) &&\n          !externalFunctionGroupsIdsSet.has(calledFunctionOrFunctionGroup)\n        );\n      }\n    );\n    if (nonExistentFunctionsOrFunctionGroups.length > 0) {\n      throw new BuildConfigError(\n        `Calling non-existent functions: ${nonExistentFunctionsOrFunctionGroups\n          .map((f) => `\"${f}\"`)\n          .join(', ')}.`\n      );\n    }\n  }\n}\n"]}