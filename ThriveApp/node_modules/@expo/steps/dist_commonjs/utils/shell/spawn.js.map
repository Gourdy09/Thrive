{"version":3,"file":"spawn.js","sourceRoot":"","sources":["../../../src/utils/shell/spawn.ts"],"names":[],"mappings":";;;;;;AAEA,yCAAiE;AACjE,oEAI2B;AAoB3B,KAAK;AAEL,sDAAsD;AACtD,SAAgB,UAAU,CACxB,OAAe,EACf,IAAc,EACd,aAA2B;IACzB,KAAK,EAAE,SAAS;IAChB,GAAG,EAAE,OAAO,CAAC,GAAG,EAAE;CACnB;IAED,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO,EAAE,GAAG,UAAU,CAAC;IAC1C,MAAM,OAAO,GAAG,IAAA,qBAAkB,EAAC,OAAO,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;IAC3D,IAAI,MAAM,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;QAC5B,IAAA,wBAAe,EAAC,MAAM,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IAClD,CAAC;IACD,OAAO,OAAO,CAAC;AACjB,CAAC;AAdD,gCAcC","sourcesContent":["import { IOType } from 'child_process';\n\nimport { pipeSpawnOutput, bunyan, PipeMode } from '@expo/logger';\nimport spawnAsyncOriginal, {\n  SpawnResult,\n  SpawnPromise,\n  SpawnOptions as SpawnOptionsOriginal,\n} from '@expo/spawn-async';\n\n// We omit 'ignoreStdio' to simplify logic -- only 'stdio' governs stdio.\n// We omit 'stdio' here to add further down in a logger-based union.\ntype SpawnOptions = Omit<SpawnOptionsOriginal, 'stdio' | 'ignoreStdio'> & {\n  lineTransformer?: (line: string) => string | null;\n  mode?: PipeMode;\n} & (\n    | {\n        // If logger is passed, we require stdio to be pipe.\n        logger: bunyan;\n        stdio: 'pipe' | [IOType, 'pipe', 'pipe', ...IOType[]];\n      }\n    | {\n        // If logger is not passed, stdio can be anything.\n        // Defaults to inherit.\n        logger?: never;\n        stdio?: SpawnOptionsOriginal['stdio'];\n      }\n  );\n// If\n\n// eslint-disable-next-line async-protect/async-suffix\nexport function spawnAsync(\n  command: string,\n  args: string[],\n  allOptions: SpawnOptions = {\n    stdio: 'inherit',\n    cwd: process.cwd(),\n  }\n): SpawnPromise<SpawnResult> {\n  const { logger, ...options } = allOptions;\n  const promise = spawnAsyncOriginal(command, args, options);\n  if (logger && promise.child) {\n    pipeSpawnOutput(logger, promise.child, options);\n  }\n  return promise;\n}\n"]}