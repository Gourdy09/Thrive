"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const logger_1 = require("@expo/logger");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const BuildStepOutput_js_1 = require("../BuildStepOutput.cjs");
const BuildStepInput_js_1 = require("../BuildStepInput.cjs");
const BuildStepContext_js_1 = require("../BuildStepContext.cjs");
const spawn_js_1 = require("../utils/shell/spawn.cjs");
async function runCustomJsFunctionAsync() {
    const customJavascriptFunctionModulePath = process.argv[2];
    const functionArgs = process.argv[3];
    (0, assert_1.default)(customJavascriptFunctionModulePath, 'customJavascriptFunctionModulePath is required');
    (0, assert_1.default)(functionArgs, 'serializedFunctionParams is required');
    let serializedFunctionArguments;
    try {
        serializedFunctionArguments = JSON.parse(functionArgs);
    }
    catch (e) {
        console.error('Failed to parse serializedFunctionParams');
        throw e;
    }
    const logger = (0, logger_1.createLogger)({
        name: 'customFunctionLogger',
        streams: [
            {
                type: 'raw',
                stream: {
                    write: (rec) => {
                        if (rec) {
                            switch (rec.level) {
                                case 20: // Debug level
                                    if (rec.msg) {
                                        console.debug(rec.msg);
                                    }
                                    break;
                                case 30: // Info level
                                    if (rec.msg) {
                                        console.log(rec.msg);
                                    }
                                    break;
                                case 40: // Warn level
                                    if (rec.msg) {
                                        console.warn(rec.msg);
                                    }
                                    break;
                                case 50: // Error level
                                case 60: // Fatal level
                                    if (rec.msg) {
                                        console.error(rec.msg);
                                    }
                                    break;
                                default:
                                    break;
                            }
                        }
                    },
                },
            },
        ],
    });
    const ctx = BuildStepContext_js_1.BuildStepContext.deserialize(serializedFunctionArguments.ctx, logger);
    const inputs = Object.fromEntries(Object.entries(serializedFunctionArguments.inputs).map(([id, input]) => [
        id,
        BuildStepInput_js_1.BuildStepInput.deserialize(input, logger),
    ]));
    const outputs = Object.fromEntries(Object.entries(serializedFunctionArguments.outputs).map(([id, output]) => [
        id,
        BuildStepOutput_js_1.BuildStepOutput.deserialize(output),
    ]));
    const env = serializedFunctionArguments.env;
    const envBefore = (0, lodash_clonedeep_1.default)(serializedFunctionArguments.env);
    let customModule;
    try {
        customModule = await require(customJavascriptFunctionModulePath);
    }
    catch (e) {
        console.error('Failed to load custom function module');
        throw e;
    }
    const customJavascriptFunction = customModule.default;
    await customJavascriptFunction(ctx, { inputs, outputs, env });
    const promises = [];
    for (const output of Object.values(outputs)) {
        if (output.rawValue) {
            (0, assert_1.default)(output.value, 'output.value is required');
            promises.push((0, spawn_js_1.spawnAsync)('set-output', [output.id, output.value], {
                env,
                stdio: 'pipe',
            }));
        }
    }
    for (const envName of Object.keys(env)) {
        const envValue = env[envName];
        if (envValue !== envBefore[envName] && envValue) {
            promises.push((0, spawn_js_1.spawnAsync)('set-env', [envName, envValue], {
                env,
                stdio: 'pipe',
            }));
        }
    }
    await Promise.all(promises);
}
void runCustomJsFunctionAsync();
//# sourceMappingURL=runCustomFunction.js.map