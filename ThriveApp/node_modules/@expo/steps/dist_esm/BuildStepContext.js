import os from 'os';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { BuildStepOutputAccessor, } from './BuildStep.js';
import { getObjectValueForInterpolation, interpolateWithGlobalContext, parseOutputPath, } from './utils/template.js';
import { BuildStepRuntimeError } from './errors.js';
export class BuildStepGlobalContext {
    constructor(provider, skipCleanup) {
        this.provider = provider;
        this.skipCleanup = skipCleanup;
        this.didCheckOut = false;
        this.stepById = {};
        this.stepsInternalBuildDirectory = path.join(os.tmpdir(), 'eas-build', uuidv4());
        this.runtimePlatform = provider.runtimePlatform;
        this.baseLogger = provider.logger;
    }
    get projectSourceDirectory() {
        return this.provider.projectSourceDirectory;
    }
    get projectTargetDirectory() {
        return this.provider.projectTargetDirectory;
    }
    get defaultWorkingDirectory() {
        return this.didCheckOut ? this.provider.defaultWorkingDirectory : this.projectTargetDirectory;
    }
    get buildLogsDirectory() {
        return this.provider.buildLogsDirectory;
    }
    get env() {
        return this.provider.env;
    }
    get staticContext() {
        return this.provider.staticContext();
    }
    updateEnv(updatedEnv) {
        this.provider.updateEnv(updatedEnv);
    }
    registerStep(step) {
        this.stepById[step.id] = step;
    }
    getStepOutputValue(path) {
        const { stepId, outputId } = parseOutputPath(path);
        if (!(stepId in this.stepById)) {
            throw new BuildStepRuntimeError(`Step "${stepId}" does not exist.`);
        }
        return this.stepById[stepId].getOutputValueByName(outputId);
    }
    interpolate(value) {
        return interpolateWithGlobalContext(value, (path) => {
            var _a, _b;
            return ((_b = (_a = getObjectValueForInterpolation(path, {
                eas: {
                    runtimePlatform: this.runtimePlatform,
                    ...this.staticContext,
                },
            })) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '');
        });
    }
    stepCtx(options) {
        return new BuildStepContext(this, options);
    }
    markAsCheckedOut(logger) {
        this.didCheckOut = true;
        logger.info(`Changing default working directory to ${this.defaultWorkingDirectory} (was ${this.projectTargetDirectory})`);
    }
    wasCheckedOut() {
        return this.didCheckOut;
    }
    serialize() {
        return {
            stepsInternalBuildDirectory: this.stepsInternalBuildDirectory,
            stepById: Object.fromEntries(Object.entries(this.stepById).map(([id, step]) => [id, step.serialize()])),
            provider: {
                projectSourceDirectory: this.provider.projectSourceDirectory,
                projectTargetDirectory: this.provider.projectTargetDirectory,
                defaultWorkingDirectory: this.provider.defaultWorkingDirectory,
                buildLogsDirectory: this.provider.buildLogsDirectory,
                runtimePlatform: this.provider.runtimePlatform,
                staticContext: this.provider.staticContext(),
                env: this.provider.env,
            },
            skipCleanup: this.skipCleanup,
        };
    }
    static deserialize(serialized, logger) {
        const deserializedProvider = {
            projectSourceDirectory: serialized.provider.projectSourceDirectory,
            projectTargetDirectory: serialized.provider.projectTargetDirectory,
            defaultWorkingDirectory: serialized.provider.defaultWorkingDirectory,
            buildLogsDirectory: serialized.provider.buildLogsDirectory,
            runtimePlatform: serialized.provider.runtimePlatform,
            logger,
            staticContext: () => serialized.provider.staticContext,
            env: serialized.provider.env,
            updateEnv: () => { },
        };
        const ctx = new BuildStepGlobalContext(deserializedProvider, serialized.skipCleanup);
        for (const [id, stepOutputAccessor] of Object.entries(serialized.stepById)) {
            ctx.stepById[id] = BuildStepOutputAccessor.deserialize(stepOutputAccessor);
        }
        ctx.stepsInternalBuildDirectory = serialized.stepsInternalBuildDirectory;
        return ctx;
    }
}
export class BuildStepContext {
    constructor(ctx, { logger, relativeWorkingDirectory, }) {
        this.ctx = ctx;
        this.logger = logger !== null && logger !== void 0 ? logger : ctx.baseLogger;
        this.relativeWorkingDirectory = relativeWorkingDirectory;
    }
    get global() {
        return this.ctx;
    }
    get workingDirectory() {
        return this.relativeWorkingDirectory
            ? path.resolve(this.ctx.defaultWorkingDirectory, this.relativeWorkingDirectory)
            : this.ctx.defaultWorkingDirectory;
    }
    serialize() {
        return {
            relativeWorkingDirectory: this.relativeWorkingDirectory,
            global: this.ctx.serialize(),
        };
    }
    static deserialize(serialized, logger) {
        const deserializedGlobal = BuildStepGlobalContext.deserialize(serialized.global, logger);
        return new BuildStepContext(deserializedGlobal, {
            logger,
            relativeWorkingDirectory: serialized.relativeWorkingDirectory,
        });
    }
}
//# sourceMappingURL=BuildStepContext.js.map