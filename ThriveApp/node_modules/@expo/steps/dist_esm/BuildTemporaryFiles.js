import path from 'path';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';
export async function saveScriptToTemporaryFileAsync(ctx, stepId, scriptContents) {
    const scriptsDir = getTemporaryScriptsDirPath(ctx, stepId);
    await fs.mkdir(scriptsDir, { recursive: true });
    const temporaryScriptPath = path.join(scriptsDir, `${uuidv4()}.sh`);
    await fs.writeFile(temporaryScriptPath, scriptContents);
    return temporaryScriptPath;
}
export async function createTemporaryOutputsDirectoryAsync(ctx, stepId) {
    const directory = getTemporaryOutputsDirPath(ctx, stepId);
    await fs.mkdir(directory, { recursive: true });
    return directory;
}
export async function createTemporaryEnvsDirectoryAsync(ctx, stepId) {
    const directory = getTemporaryEnvsDirPath(ctx, stepId);
    await fs.mkdir(directory, { recursive: true });
    return directory;
}
export async function cleanUpStepTemporaryDirectoriesAsync(ctx, stepId) {
    if (ctx.skipCleanup) {
        return;
    }
    const stepTemporaryDirectory = getTemporaryStepDirPath(ctx, stepId);
    await fs.rm(stepTemporaryDirectory, { recursive: true, force: true });
    ctx.baseLogger.debug({ stepTemporaryDirectory }, 'Removed step temporary directory');
}
function getTemporaryStepDirPath(ctx, stepId) {
    return path.join(ctx.stepsInternalBuildDirectory, 'steps', stepId);
}
function getTemporaryScriptsDirPath(ctx, stepId) {
    return path.join(getTemporaryStepDirPath(ctx, stepId), 'scripts');
}
function getTemporaryOutputsDirPath(ctx, stepId) {
    return path.join(getTemporaryStepDirPath(ctx, stepId), 'outputs');
}
function getTemporaryEnvsDirPath(ctx, stepId) {
    return path.join(getTemporaryStepDirPath(ctx, stepId), 'envs');
}
//# sourceMappingURL=BuildTemporaryFiles.js.map