{"version":3,"file":"jsepEval.js","sourceRoot":"","sources":["../../src/utils/jsepEval.ts"],"names":[],"mappings":"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","sourcesContent":["// https://github.com/Sensative/jsep-eval/blob/master/src/jsep-eval.js\n\nimport assert from 'assert';\n\nimport get from 'lodash.get';\nimport jsep from 'jsep';\n\nconst binaryOperatorFunctions = {\n  '===': (a: any, b: any) => a === b,\n  '!==': (a: any, b: any) => a !== b,\n  '==': (a: any, b: any) => a == b, // eslint-disable-line\n  '!=': (a: any, b: any) => a != b, // eslint-disable-line\n  '>': (a: any, b: any) => a > b,\n  '<': (a: any, b: any) => a < b,\n  '>=': (a: any, b: any) => a >= b,\n  '<=': (a: any, b: any) => a <= b,\n  '+': (a: any, b: any) => a + b,\n  '-': (a: any, b: any) => a - b,\n  '*': (a: any, b: any) => a * b,\n  '/': (a: any, b: any) => a / b,\n  '%': (a: any, b: any) => a % b, // remainder\n  '**': (a: any, b: any) => a ** b, // exponentiation\n  '&': (a: any, b: any) => a & b, // bitwise AND\n  '|': (a: any, b: any) => a | b, // bitwise OR\n  '^': (a: any, b: any) => a ^ b, // bitwise XOR\n  '<<': (a: any, b: any) => a << b, // left shift\n  '>>': (a: any, b: any) => a >> b, // sign-propagating right shift\n  '>>>': (a: any, b: any) => a >>> b, // zero-fill right shift\n  // Let's make a home for the logical operators here as well\n  '||': (a: any, b: any) => a || b,\n  '&&': (a: any, b: any) => a && b,\n};\ntype BinaryOperator = keyof typeof binaryOperatorFunctions;\n\nconst unaryOperatorFunctions = {\n  '!': (a: any) => !a,\n  '~': (a: any) => ~a, // bitwise NOT\n  '+': (a: any) => +a, // unary plus\n  '-': (a: any) => -a, // unary negation\n  '++': (a: any) => ++a, // increment\n  '--': (a: any) => --a, // decrement\n};\ntype UnaryOperator = keyof typeof unaryOperatorFunctions;\n\nfunction isValid<T extends jsep.ExpressionType>(\n  expression: jsep.Expression,\n  types: T[]\n): expression is jsep.CoreExpression & { type: T } {\n  return types.includes(expression.type as T);\n}\n\nconst getParameterPath = (\n  node: jsep.MemberExpression,\n  context: Record<string, unknown>\n): string => {\n  // it's a MEMBER expression\n  // EXAMPLES:  a[b] (computed)\n  //            a.b (not computed)\n  const computed = node.computed;\n  const object = node.object;\n  const property = node.property;\n\n  // object is either 'IDENTIFIER', 'MEMBER', or 'THIS'\n  assert(\n    isValid(object, ['MemberExpression', 'Identifier', 'ThisExpression']),\n    'Invalid object type'\n  );\n  assert(property, 'Member expression property is missing');\n\n  let objectPath = '';\n  if (object.type === 'ThisExpression') {\n    objectPath = '';\n  } else if (isValid(object, ['Identifier'])) {\n    objectPath = object.name;\n  } else {\n    objectPath = getParameterPath(object, context);\n  }\n\n  if (computed) {\n    // if computed -> evaluate anew\n    const propertyPath = evaluateExpressionNode(property, context);\n    return objectPath + '[' + propertyPath + ']';\n  } else if (isValid(property, ['Identifier'])) {\n    return (objectPath ? objectPath + '.' : '') + property.name;\n  } else {\n    assert(isValid(property, ['MemberExpression']), 'Invalid object type');\n    const propertyPath = getParameterPath(property, context);\n    return (objectPath ? objectPath + '.' : '') + propertyPath;\n  }\n};\n\nconst evaluateExpressionNode = (node: jsep.Expression, context: Record<string, unknown>): any => {\n  switch (node.type as jsep.ExpressionType) {\n    case 'Literal': {\n      return (node as jsep.Literal).value;\n    }\n    case 'ThisExpression': {\n      return context;\n    }\n    case 'Compound': {\n      const compoundNode = node as jsep.Compound;\n      const expressions = compoundNode.body.map((el) => evaluateExpressionNode(el, context));\n      return expressions.pop();\n    }\n    case 'UnaryExpression': {\n      const unaryNode = node as jsep.UnaryExpression;\n      if (!(unaryNode.operator in unaryOperatorFunctions)) {\n        throw new Error(`Unsupported unary operator: ${unaryNode.operator}`);\n      }\n      const operatorFn = unaryOperatorFunctions[unaryNode.operator as UnaryOperator];\n      const argument = evaluateExpressionNode(unaryNode.argument, context);\n      return operatorFn(argument);\n    }\n    case 'BinaryExpression': {\n      const binaryNode = node as jsep.BinaryExpression;\n      if (!(binaryNode.operator in binaryOperatorFunctions)) {\n        throw new Error(`Unsupported binary operator: ${binaryNode.operator}`);\n      }\n      const operator = binaryOperatorFunctions[binaryNode.operator as BinaryOperator];\n      const left = evaluateExpressionNode(binaryNode.left, context);\n      const right = evaluateExpressionNode(binaryNode.right, context);\n      return operator(left, right);\n    }\n    case 'ConditionalExpression': {\n      const conditionalNode = node as jsep.ConditionalExpression;\n      const test = evaluateExpressionNode(conditionalNode.test, context);\n      const consequent = evaluateExpressionNode(conditionalNode.consequent, context);\n      const alternate = evaluateExpressionNode(conditionalNode.alternate, context);\n      return test ? consequent : alternate;\n    }\n    case 'CallExpression': {\n      const allowedCalleeTypes: jsep.ExpressionType[] = [\n        'MemberExpression',\n        'Identifier',\n        'ThisExpression',\n      ];\n      const callNode = node as jsep.CallExpression;\n      if (!allowedCalleeTypes.includes(callNode.callee.type as jsep.ExpressionType)) {\n        throw new Error(\n          `Invalid function callee type: ${\n            callNode.callee.type\n          }. Expected one of ${allowedCalleeTypes.join(', ')}.`\n        );\n      }\n      const callee = evaluateExpressionNode(callNode.callee, context);\n      const args = callNode.arguments.map((arg) => evaluateExpressionNode(arg, context));\n      // eslint-disable-next-line prefer-spread\n      return callee.apply(null, args);\n    }\n    case 'Identifier': {\n      const identifier = (node as jsep.Identifier).name;\n      if (!(identifier in context)) {\n        throw new Error(\n          `Invalid identifier \"${identifier}\". Expected one of ${Object.keys(context).join(', ')}`\n        );\n      }\n      return get(context, identifier);\n    }\n    case 'MemberExpression': {\n      const path = getParameterPath(node as jsep.MemberExpression, context);\n      return get(context, path);\n    }\n    case 'ArrayExpression': {\n      const elements = (node as jsep.ArrayExpression).elements.map((el) =>\n        evaluateExpressionNode(el, context)\n      );\n      return elements;\n    }\n    default:\n      throw new Error(`Unsupported expression type: ${node.type}`);\n  }\n};\n\nexport const jsepEval = (expression: string, context?: Record<string, unknown>): any => {\n  const tree = jsep(expression);\n  return evaluateExpressionNode(tree, context ?? {});\n};\n"]}