"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMultipartPartWithName = exports.parseMultipartMixedResponseAsync = void 0;
const dicer_1 = __importDefault(require("dicer"));
const nullthrows_1 = __importDefault(require("nullthrows"));
const stream_1 = require("stream");
const structured_headers_1 = require("structured-headers");
/**
 * Parse a multipart response into an array of {@link MultipartPart}. All part bodies are decoded as UTF-8 strings.
 * @param contentTypeHeader - value of the content-type header from the response
 * @param bodyBuffer - buffer of the body from the response
 * @returns - array of {@link MultipartPart}
 */
async function parseMultipartMixedResponseAsync(contentTypeHeader, bodyBuffer) {
    var _a;
    const boundaryRegex = /^multipart\/.+?; boundary=(?:"([^"]+)"|([^\s;]+))/i;
    const matches = boundaryRegex.exec(contentTypeHeader);
    if (!matches) {
        throw new Error('The content-type header in the HTTP response is not a multipart media type');
    }
    const boundary = (_a = matches[1]) !== null && _a !== void 0 ? _a : matches[2];
    const bufferStream = new stream_1.Stream.PassThrough();
    bufferStream.end(bodyBuffer);
    return await new Promise((resolve, reject) => {
        const parts = [];
        bufferStream.pipe(new dicer_1.default({ boundary })
            .on('part', (p) => {
            const part = {
                body: '',
                headers: new Map(),
            };
            p.on('header', (headers) => {
                for (const h in headers) {
                    part.headers.set(h, headers[h][0]);
                }
            });
            p.on('data', (data) => {
                part.body += data.toString('utf-8');
            });
            p.on('end', () => {
                parts.push(part);
            });
        })
            .on('finish', () => {
            resolve(parts);
        })
            .on('error', (error) => {
            reject(error);
        }));
    });
}
exports.parseMultipartMixedResponseAsync = parseMultipartMixedResponseAsync;
function isMultipartPartWithName(multipartPart, name) {
    const [, parameters] = (0, structured_headers_1.parseItem)((0, nullthrows_1.default)(multipartPart.headers.get('content-disposition')));
    const partNameParameter = parameters.get('name');
    return partNameParameter === name;
}
exports.isMultipartPartWithName = isMultipartPartWithName;
//# sourceMappingURL=index.js.map